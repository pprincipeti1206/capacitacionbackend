/*
 * Project home: https://github.com/jaxio/celerio-angular-quickstart
 *
 * Source code generated by Celerio, an Open Source code generator by Jaxio.
 * Documentation: http://www.jaxio.com/documentation/celerio/
 * Modificado por CARLOS BAZALAR
 * Email: cbazalarlarosa@gmail.com
 * Template pack-angular:src/main/java/rest/EntitydeltaResource.java.e.vm
 */
package com.incloud.hcp.rest.delta;

import com.incloud.hcp._security.SystemLoggedUser;
import com.incloud.hcp._security.UserSession;
import com.incloud.hcp.bean.custom.*;
import com.incloud.hcp.cmis.CmisFile;
import com.incloud.hcp.common.BindingErrorsResponse;
import com.incloud.hcp.domain.*;
import com.incloud.hcp.domain.response.FacFacturaResponse;
import com.incloud.hcp.enums.TipoFacturaAdjuntoEnum;
import com.incloud.hcp.mapper.FacFacturaMapper;
import com.incloud.hcp.repository.delta.*;
import com.incloud.hcp.rest.FacFacturaRest;
import com.incloud.hcp.service.delta.FacFacturaDeltaCompletableFutureService;
import com.incloud.hcp.service.delta.SapRfcDeltaService;
import com.incloud.hcp.service.dto.*;
import com.incloud.hcp.service.support.PageResponse;
import com.incloud.hcp.service.wsdlSunat.BillConsultPortBidingServiceLocator;
import com.incloud.hcp.service.wsdlSunat.BillConsultService;
import com.incloud.hcp.service.wsdlSunat.StatusResponse;
import com.incloud.hcp.service.wsdlSunat.flyWeight.FunctionsXML;
import com.incloud.hcp.util.Utils;
import com.incloud.hcp.utils.Constants;
import com.incloud.hcp.utils.DateUtils;
import com.incloud.hcp.utils.NumberUtils;
import io.swagger.annotations.ApiOperation;
import org.apache.axis.client.Stub;
import org.apache.axis.message.MessageElement;
import org.apache.axis.message.PrefixedQName;
import org.apache.axis.message.SOAPHeaderElement;
import org.apache.commons.lang.StringUtils;
import org.apache.poi.xssf.streaming.SXSSFWorkbook;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.data.domain.PageRequest;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import org.w3c.dom.Document;
import org.w3c.dom.NodeList;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathFactory;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.math.BigDecimal;
import java.net.URISyntaxException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

import static org.springframework.http.MediaType.APPLICATION_JSON_VALUE;

@RestController
@RequestMapping("/api/facFactura")
public class FacFacturaDeltaRest extends FacFacturaRest {

    private final Logger log = LoggerFactory.getLogger(FacFacturaDeltaRest.class);

    @Autowired
    private MtrUsuarioFacturacionDeltaRepository mtrUsuarioFacturacionDeltaRepository;

    @Autowired
    protected FacFacturaDeltaRepository facFacturaDeltaRepository;

    @Autowired
    protected FacFacturaMapper facFacturaMapper;

    @Autowired
    protected FacFacturaCertificadoDeltaRepository facFacturaCertificadoDeltaRepository;

    @Autowired
    protected MtrProveedorDeltaRepository mtrProveedorDeltaRepository;

    @Autowired
    protected MtrSociedadDeltaRepository mtrSociedadDeltaRepository;

    @Autowired
    protected MtrEstadoDeltaRepository mtrEstadoDeltaRepository;

    @Autowired
    private SapRfcDeltaService sapRfcDeltaService;

    @Autowired
    protected SystemLoggedUser systemLoggedUser;

    @Autowired
    private FacFacturaDeltaCompletableFutureService facFacturaDeltaCompletableFutureService;

    @Autowired
    private AppParametriaDeltaRepository appParametriaDeltaRepository;

    @Autowired
    private FacHistorialDeltaRepository facHistorialDeltaRepository;



    @Value("${cfg.sunat.user}")
    private String repositoryUser;

    @Value("${cfg.sunat.pass}")
    private String repositoryPass;


    @GetMapping(value = "/_devuelveDatosProveedorSunat/{rucProveedor}", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<DatosProveedorSunatDto> devuelveDatosProveedorSunat(@PathVariable("rucProveedor") String rucProveedor) {
        HttpHeaders headers = new HttpHeaders();
        try {
            return Optional.ofNullable(this.facFacturaDeltaService.devuelveDatosProveedorSunat(rucProveedor))
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        } catch (Exception e) {
            if (this.devuelveRuntimeException) {
                throw new RuntimeException(e);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }

    @ApiOperation(value = "Valida Comprobante XML por proveedor logueado", produces = "application/json")
    @PostMapping(value = "/_validarComprobanteProveedor",produces = {MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE})
    public ResponseEntity<MensajePrefactura> validarComprobanteProveedor(@RequestParam(value = "file") MultipartFile archivoSunat){
        MensajePrefactura bean = new MensajePrefactura();
        String codess;
        String messages;
        String serieComprobante;
        String nroComprobante;
        PrefacturaDto prefactura = new PrefacturaDto();
        UserSession userSession = this.systemLoggedUser.getUserSession();
        MtrProveedor mtrProveedor = this.mtrProveedorDeltaRepository.findByCodigoIdp(userSession.getId());
        if (!Optional.ofNullable(mtrProveedor).isPresent()) {
            bean.setType("EL");
            bean.setMensaje("No existe Proveedor asociado al IDP con CÃ³digo: " + userSession.getId());
        }
        else {

            try {
                File sunatXml = FunctionsXML.convert(archivoSunat);
                DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
                DocumentBuilder db = dbf.newDocumentBuilder();
                Document doc = db.parse(sunatXml);

                XPath xPath = XPathFactory.newInstance().newXPath();
                String referenciaFactura = xPath.compile("/Invoice/ID").evaluate(doc);
                String igvAlt = xPath.compile("/Invoice/TaxTotal/TaxAmount").evaluate(doc);
                String rucProveedorAlt = xPath.compile("/Invoice/AccountingSupplierParty/Party/PartyIdentification/ID").evaluate(doc);
                String rucClienteAlt = xPath.compile("/Invoice/AccountingCustomerParty/Party/PartyIdentification/ID").evaluate(doc);

                try {
                    doc.getDocumentElement().normalize();
                    NodeList ProveedorNodeList = doc.getElementsByTagName("cac:AccountingSupplierParty");
                    NodeList ClienteNodeList = doc.getElementsByTagName("cac:AccountingCustomerParty");
                    NodeList FacturaNodeList = doc.getElementsByTagName("Invoice");
                    NodeList TaxSubTotalNodeList = doc.getElementsByTagName("cac:TaxTotal");
                    NodeList TaxTotalNodeList = doc.getElementsByTagName("cac:LegalMonetaryTotal");
                    NodeList PaymentTotalNodeList = doc.getElementsByTagName("cac:PaymentTerms");
                    NodeList AllowanceChargeNodeList = doc.getElementsByTagName("cac:AllowanceCharge");

                    String rucProveedor = FunctionsXML.getTagValueHTML(ProveedorNodeList, "cbc:ID");
                    String rucCliente = FunctionsXML.getTagValueHTML(ClienteNodeList, "cbc:ID");
                    if (!mtrProveedor.getRuc().equals(rucProveedor)) {
                        throw new Exception("Archivo XML no corresponde con el Proveedor logueado");
                    }

                    if (!NumberUtils.stringIsLong(rucProveedor) && rucProveedor.length() != 11) {
                        rucProveedor = rucProveedorAlt;
                    }

                    if (!NumberUtils.stringIsLong(rucCliente) && rucCliente.length() != 11) {
                        rucCliente = rucClienteAlt;
                    }

                    String tipoComprobante = FunctionsXML.getTagValueHTML(FacturaNodeList, "cbc:InvoiceTypeCode");
                    String montoTotal = FunctionsXML.getTagValueHTML(TaxTotalNodeList, "cbc:PayableAmount");
                    String igv = "";
                    String subTotal = "";
                    try {
                        List<String> taxSubTotalList = FunctionsXML.getTagValueIntoTagHTML(TaxSubTotalNodeList, "cbc:Name", "IGV", "cbc:TaxAmount", "cbc:TaxableAmount");
                        igv = taxSubTotalList.get(0);
                        subTotal = taxSubTotalList.get(1);
                    }
                    catch(Exception ex) {
                        igv = FunctionsXML.getTagValueHTML(TaxSubTotalNodeList, "cbc:TaxAmount");
                        subTotal = FunctionsXML.getTagValueHTML(TaxSubTotalNodeList, "cbc:TaxableAmount");
                    }

                    if (!NumberUtils.stringIsBigDecimal(igv) || ((new BigDecimal(igv).compareTo(BigDecimal.ZERO)) == 0 && (new BigDecimal(igvAlt).compareTo(BigDecimal.ZERO)) > 0)) {
                        igv = igvAlt;
                    }
                    subTotal = (new BigDecimal(montoTotal).compareTo(BigDecimal.ZERO) > 0) ? (new BigDecimal(montoTotal).subtract(new BigDecimal(igv))).toString() : subTotal;

                    if (!NumberUtils.stringIsBigDecimal(subTotal) || ((new BigDecimal(subTotal).compareTo(BigDecimal.ZERO)) == 0)) {
                        String subTotalAlt = FunctionsXML.getTagValueHTML(TaxTotalNodeList, "cbc:LineExtensionAmount");
                        if (NumberUtils.stringIsBigDecimal(subTotalAlt)) {
                            subTotal = (new BigDecimal(subTotalAlt).compareTo(BigDecimal.ZERO) > 0) ? subTotalAlt : (new BigDecimal(montoTotal).subtract(new BigDecimal(igv))).toString();
                        }
                    }

                    BigDecimal nSubTotal = new BigDecimal(subTotal);
                    BigDecimal nOtrosCargos = new BigDecimal(0.0);
                    String otrosCargos = "";
                    try {
                        otrosCargos = FunctionsXML.getTagValueHTML(TaxTotalNodeList, "cbc:ChargeTotalAmount");
                        nOtrosCargos = new BigDecimal(otrosCargos);
                    }
                    catch(Exception ex) {

                    }

//                    BigDecimal nOtrosServicios = new BigDecimal(0.0);
//                    String otrosServicios = "";
//                    try {
//                        otrosServicios = FunctionsXML.getTagValueHTML(AllowanceChargeNodeList, "cbc:Amount");
//                        nOtrosServicios = new BigDecimal(otrosServicios);
//                    }
//                    catch(Exception ex) {
//
//                    }
//                    if (nOtrosServicios.floatValue() >= nSubTotal.floatValue()) {
//                        nOtrosServicios = new BigDecimal(0.0);
//                    }
//
//                    if (nOtrosCargos.floatValue() == 0.0) {
//                        nOtrosCargos = new BigDecimal(
//                                nOtrosCargos.floatValue() +
//                                        nOtrosServicios.floatValue()).setScale(2, BigDecimal.ROUND_HALF_UP);
//                    }
                    otrosCargos = nOtrosCargos.toString();


                    nSubTotal = new BigDecimal(nSubTotal.floatValue() - nOtrosCargos.floatValue())
                            .setScale(2, BigDecimal.ROUND_HALF_EVEN);
                    subTotal = new String(nSubTotal.toString().trim());

                    String detraccion = "";
                    try {
                        detraccion = FunctionsXML.getTagValueHTML(PaymentTotalNodeList, "cbc:Amount");
                    } catch (Exception ex) {
                        detraccion = "";
                    }

                    String[] refFacturaStrings = referenciaFactura.split("-");
                    serieComprobante = refFacturaStrings[0];
                    nroComprobante = refFacturaStrings[1];

                    BillConsultPortBidingServiceLocator locator = new BillConsultPortBidingServiceLocator();
                    //locator.setBillConsultServicePortEndpointAddress("https://www.sunat.gob.pe/ol-it-wsconscpegem/billConsultService");
                    locator.setBillConsultServicePortEndpointAddress("https://ww1.sunat.gob.pe/ol-it-wsconscpegem/billConsultService");
                    BillConsultService port = locator.getBillConsultServicePort();
                    Stub stub = ((Stub) port);
                    int nroComprobanteInteger = Integer.parseInt(nroComprobante + "");
                    SOAPHeaderElement wsseSecurity = new SOAPHeaderElement(new PrefixedQName("http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd", "Security", "wsse"));
                    MessageElement usernameToken = new MessageElement("http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd", "wsse:UsernameToken");
                    MessageElement username = new MessageElement("http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd", "wsse:Username");
                    MessageElement password = new MessageElement("http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd", "wsse:Password");

                    username.setObjectValue(rucCliente.concat(repositoryUser));
                    usernameToken.addChild(username);
                    password.setObjectValue(repositoryPass);
                    usernameToken.addChild(password);
                    wsseSecurity.addChild(usernameToken);
                    stub.setHeader(wsseSecurity);
                    StatusResponse ff = port.getStatus(rucProveedor, tipoComprobante, serieComprobante, nroComprobanteInteger);

                    codess = ff.getStatusCode();
                    messages = ff.getStatusMessage();
                    if (codess.equalsIgnoreCase("0001") || codess.equalsIgnoreCase("0009") || codess.equalsIgnoreCase("0010")) {
                        bean.setType("S");
                        bean.setMensaje(messages);
                    } else {
                        bean.setType("E");
                        bean.setMensaje(messages);
                    }

                    String fechaEmisionString = FunctionsXML.getTagValueHTML(FacturaNodeList, "cbc:IssueDate");
                    String codigoMoneda = FunctionsXML.getTagValueHTML(FacturaNodeList, "cbc:DocumentCurrencyCode");
                    //Date fechaEmision = DateUtils.stringToUtilDate(fechaEmisionString);
                    Date fechaEmision = DateUtils.convertStringToDate("yyyy-MM-dd", fechaEmisionString);
                    if (codigoMoneda.equals(Constants.SIGLA_PERU_MONEDA)) {
                        codigoMoneda = Constants.SIGLA_PERU_MONEDA_ALTERNATIVO;
                    }


                    MtrSociedad mtrSociedad = this.mtrSociedadDeltaRepository.getByRuc(rucCliente);
                    fechaEmisionString = DateUtils.convertDateToString("dd/MM/yyyy", fechaEmision);
                    prefactura.setFechaEmisionString(fechaEmisionString);
                    prefactura.setSociedad(mtrSociedad.getDescBrv());
                    prefactura.setRazonSocial(mtrSociedad.getDescripcion());
                    prefactura.setProveedorRuc(rucProveedor);
                    prefactura.setFechaEmision(fechaEmision);
                    prefactura.setReferencia(referenciaFactura);
                    prefactura.setCodigoMoneda(codigoMoneda);
                    prefactura.setIgv(igv);
                    prefactura.setSubTotal(subTotal);
                    prefactura.setTotal(montoTotal);
                    prefactura.setDetraccion(detraccion);
                    prefactura.setOtrosCargo(otrosCargos);
                    // prefactura.setObservaciones(    );

                    bean.setPrefactura(prefactura);
                    if (sunatXml.exists()) {
                        sunatXml.delete();
                    }
                }
                catch (Exception efac) {
                    throw new Exception("Formato XML invÃ¡lido. Debe ingresar el XML proporcionado por Sunat");
                }


            } catch (IOException e) {
                messages = e.toString();
                bean.setType("EX");
                if (messages.equalsIgnoreCase("El Usuario ingresado no existe")) { // si el RUC del receptor no es uno valido, el usuario de autenticacion generado usando dicho RUC no es correcto
                    messages = "El receptor no es el correcto";
                }
                bean.setMensaje(messages);
                System.out.println(e.toString());
            } catch (Exception e) {
                // TODO: handle exception
                messages = e.toString();
                bean.setType("EL");
                bean.setMensaje(messages);
                System.out.println(e.toString());
            }
        }

        return new ResponseEntity<>(bean, HttpStatus.OK);
    }

    @ApiOperation(value = "Obtener comporbante y actualizar pagos de factura v2", produces = "application/json")
    @PostMapping(value = "/obtenerComprobanteSapV2",produces = {MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE})
    public ResponseEntity<MensajeSap> btenerComprobanteSapV2(@RequestBody RangoFechaInput bean){
        java.text.SimpleDateFormat format = new java.text.SimpleDateFormat("dd/MM/yyyy");
        java.text.SimpleDateFormat formatOut = new java.text.SimpleDateFormat("yyyy/MM/dd");

        try {

            //AppParametria claseDocumento = this.appParametriaDeltaRepository.obtenerParametroPorModuloYLabel("Consulta_Comprobante", "CLASE_DOCUMENTO");
            AppParametria estado = this.appParametriaDeltaRepository.obtenerParametroPorModuloYLabel("Consulta_Comprobante", "Estado");
            List<AppParametria> claseDocumento = appParametriaDeltaRepository.findByModuloAndLabelAndStatus("Consulta_Comprobante", "CLASE_DOCUMENTO", "1");
            AppParametria sociedad = this.appParametriaDeltaRepository.obtenerParametroPorModuloYLabel("Consulta_Comprobante", "SOCIEDAD");
            // AppParametria claseDocumento = this.appParametriaDeltaRepository.obtenerParametroPorModuloYLabel("Consulta_Comprobante", "CLASE_DOCUMENTO");
            //String arrFechaInicio =
            Date dateHoy = format.parse(bean.getFechaInicio());
            Date dateAyer = format.parse(bean.getFechaFin());


            List<IndicadorFiscalSap> listaIndicador = new ArrayList<>();


            List<RangeSap> listaFecha = new ArrayList<RangeSap>();
            RangeSap rangeFecha = new RangeSap();
            rangeFecha.setSign("I");
            rangeFecha.setOption("BT");
            rangeFecha.setLow(formatOut.format(dateAyer));
            rangeFecha.setHigh(formatOut.format(dateHoy));

            listaFecha.add(rangeFecha);

            List<RangeSap> listaClaseDoc = new ArrayList<RangeSap>();
            if (claseDocumento != null && claseDocumento.size() > 0) {
                for (AppParametria ele : claseDocumento) {
                    RangeSap rangeClase = new RangeSap();
                    rangeClase.setSign("I");
                    rangeClase.setOption("EQ");
                    rangeClase.setLow(ele.getValue1());
                    rangeClase.setHigh("");

                    listaClaseDoc.add(rangeClase);
                }
            }

            List<RangeSap> listaRangeSociedad = new ArrayList<RangeSap>();
            List<MtrSociedad> listaSociedad = this.mtrSociedadDeltaRepository.findAll();
            for (MtrSociedad soc : listaSociedad) {
                RangeSap rg = new RangeSap();
                rg.setSign("I");
                rg.setOption("EQ");
                rg.setLow(soc.getDescBrv());
                rg.setHigh("");
                listaRangeSociedad.add(rg);
            }

            List<ComprobantePagoSap> lista = this.sapRfcDeltaService.obtenerComprobantesPagoV2(listaRangeSociedad,
                    listaClaseDoc, listaFecha);
            log.error("RESTobtenerComprobanteSapV2 rest :: if(lista != null) { ");
            if (lista != null) {
                log.error("RESTobtenerComprobanteSapV2 rest :: 1 ");
                for (ComprobantePagoSap ele : lista) {

                    //List<FacFactura> listaFact = this.facFacturaDeltaRepository.devuelveFacturaPorNumeroFacturaSap(ele.getBelnr().trim());
                    List<FacFactura> listaFact = null;
                    FacFactura factura = null;
                    /*if(listaFact != null && listaFact.size() > 0) {

                        logger.error("scheduleObtenerComprobanteSapV2 rest :: 3 ");
                    }else {*/
                    log.error("RESTobtenerComprobanteSapV2 rest  :: 4 " + ele.getXblnr() + " ---- " + ele.getGjahr() + " ---- " + ele.getStcd1());
                    String[] arrCode = ele.getXblnr().trim().split("-");
                    String tipoComprobante = arrCode[0];
                    String serie = arrCode[1];
                    String numeroFactura = arrCode[2];


                    //ele.getGjahr() -- aino
                    listaFact = this.facFacturaDeltaRepository.devuelveFacturaPorCodigoUnico(numeroFactura, serie, tipoComprobante, ele.getStcd1().trim(), ele.getGjahr().trim());
                    if (listaFact != null && listaFact.size() > 0) {
                        factura = listaFact.get(0);
                        log.error("RESTobtenerComprobanteSapV2 rest :: unico " + ele.getBelnr());

                    }


                    // }
                    log.error("RESTobtenerComprobanteSapV2 rest :: 5 ");
                    if (factura != null && StringUtils.isBlank(factura.getDocumentoPagoSap())) {
                        log.error("RESTobtenerComprobanteSapV2 rest :: 5_1 " + factura.getId());

                        MtrEstado objEstado = this.mtrEstadoDeltaRepository.getByCodigoAgrupadoAndCodigoEstado(estado.getValue1(), estado.getValue2());
                        //=================================================================
                        log.error("RESTobtenerComprobanteSapV2 rest :: 6");

                        factura.setMtrEstado(objEstado);
                        factura.setDocumentoPagoSap(ele.getAugbl());
                        if (ele.getAugdt() != null) {
                            log.error("RESTobtenerComprobanteSapV2 ele.getAugdt() :: 6_1 " + ele.getAugdt());
                            factura.setFechaPago(ele.getAugdt());
                        }
                        //factura.setFechaPago();
                        FacFactura facx = this.facFacturaDeltaRepository.save(factura);
                        //==================================================Historial
                        FacHistorial facHistorial = new FacHistorial();
                        facHistorial.setDescripcion("Documento pagado por SAP");
                        facHistorial.setMtrEstado(objEstado);
                        facHistorial.setFechaHistorial(DateUtils.obtenerFechaHoraActual());
                        facHistorial.setFacFactura(facx);
                        facHistorial.setUsuarioHistorial("SAP");
                        this.facHistorialDeltaRepository.save(facHistorial);
                        log.error("RESTobtenerComprobanteSapV2 rest :: 6_1");
                    }

                }
            }
        }catch(Exception e) {

        }finally {

        }
        MensajeSap msg = new MensajeSap("S", "", "Los datos se procesaron correctamente");

        return new ResponseEntity<>(msg, HttpStatus.OK);
    }



    @ApiOperation(value = "Valida Comprobante XML", produces = "application/json")
    @PostMapping(value = "/_validarComprobante",produces = {MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE})
    public ResponseEntity<MensajePrefactura> validarComprobante(@RequestParam(value = "file") MultipartFile archivoSunat){
        MensajePrefactura bean = new MensajePrefactura();
        String codess;
        String messages;
        String serieComprobante;
        String nroComprobante;
        PrefacturaDto prefactura = new PrefacturaDto();

        try {
            File sunatXml = FunctionsXML.convert(archivoSunat);
            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
            DocumentBuilder db = dbf.newDocumentBuilder();
            Document doc = db.parse(sunatXml);

            XPath xPath = XPathFactory.newInstance().newXPath();
            String referenciaFactura = xPath.compile("/Invoice/ID").evaluate(doc);
            String igvAlt = xPath.compile("/Invoice/TaxTotal/TaxAmount").evaluate(doc);
            String rucProveedorAlt = xPath.compile("/Invoice/AccountingSupplierParty/Party/PartyIdentification/ID").evaluate(doc);
            String rucClienteAlt = xPath.compile("/Invoice/AccountingCustomerParty/Party/PartyIdentification/ID").evaluate(doc);

            try {
                doc.getDocumentElement().normalize();
                NodeList ProveedorNodeList = doc.getElementsByTagName("cac:AccountingSupplierParty");
                NodeList ClienteNodeList = doc.getElementsByTagName("cac:AccountingCustomerParty");
                NodeList FacturaNodeList = doc.getElementsByTagName("Invoice");
                NodeList TaxSubTotalNodeList = doc.getElementsByTagName("cac:TaxTotal");
                NodeList TaxTotalNodeList = doc.getElementsByTagName("cac:LegalMonetaryTotal");
                NodeList PaymentTotalNodeList = doc.getElementsByTagName("cac:PaymentTerms");
                NodeList AllowanceChargeNodeList = doc.getElementsByTagName("cac:AllowanceCharge");

                String rucProveedor = FunctionsXML.getTagValueHTML(ProveedorNodeList, "cbc:ID");
                String rucCliente = FunctionsXML.getTagValueHTML(ClienteNodeList, "cbc:ID");

                if (!NumberUtils.stringIsLong(rucProveedor) && rucProveedor.length() != 11) {
                    rucProveedor = rucProveedorAlt;
                }

                if (!NumberUtils.stringIsLong(rucCliente) && rucCliente.length() != 11) {
                    rucCliente = rucClienteAlt;
                }

                String tipoComprobante = FunctionsXML.getTagValueHTML(FacturaNodeList, "cbc:InvoiceTypeCode");
                String montoTotal = FunctionsXML.getTagValueHTML(TaxTotalNodeList, "cbc:PayableAmount");

                String igv = "";
                String subTotal = "";
                try {
                    List<String> taxSubTotalList = FunctionsXML.getTagValueIntoTagHTML(TaxSubTotalNodeList, "cbc:Name", "IGV", "cbc:TaxAmount", "cbc:TaxableAmount");
                    igv = taxSubTotalList.get(0);
                    subTotal = taxSubTotalList.get(1);
                }
                catch(Exception ex) {
                    igv = FunctionsXML.getTagValueHTML(TaxSubTotalNodeList, "cbc:TaxAmount");
                    subTotal = FunctionsXML.getTagValueHTML(TaxSubTotalNodeList, "cbc:TaxableAmount");
                }


                if (!NumberUtils.stringIsBigDecimal(igv) || ((new BigDecimal(igv).compareTo(BigDecimal.ZERO)) == 0 && (new BigDecimal(igvAlt).compareTo(BigDecimal.ZERO)) > 0)) {
                    igv = igvAlt;
                }

                subTotal = (new BigDecimal(montoTotal).compareTo(BigDecimal.ZERO) > 0) ? (new BigDecimal(montoTotal).subtract(new BigDecimal(igv))).toString() : subTotal;

                if (!NumberUtils.stringIsBigDecimal(subTotal) || ((new BigDecimal(subTotal).compareTo(BigDecimal.ZERO)) == 0)) {
                    String subTotalAlt = FunctionsXML.getTagValueHTML(TaxTotalNodeList, "cbc:LineExtensionAmount");
                    if (NumberUtils.stringIsBigDecimal(subTotalAlt)) {
                        subTotal = (new BigDecimal(subTotalAlt).compareTo(BigDecimal.ZERO) > 0) ? subTotalAlt : (new BigDecimal(montoTotal).subtract(new BigDecimal(igv))).toString();
                    }
                }

                BigDecimal nSubTotal = new BigDecimal(subTotal);
                BigDecimal nOtrosCargos = new BigDecimal(0.0);
                String otrosCargos = "";
                try {
                    otrosCargos = FunctionsXML.getTagValueHTML(TaxTotalNodeList, "cbc:ChargeTotalAmount");
                    nOtrosCargos = new BigDecimal(otrosCargos);
                }
                catch(Exception ex) {

                }

//                BigDecimal nOtrosServicios = new BigDecimal(0.0);
//                String otrosServicios = "";
//                try {
//                    otrosServicios = FunctionsXML.getTagValueHTML(AllowanceChargeNodeList, "cbc:Amount");
//                    nOtrosServicios = new BigDecimal(otrosServicios);
//                }
//                catch(Exception ex) {
//
//                }
//                if (nOtrosServicios.floatValue() >= nSubTotal.floatValue()) {
//                    nOtrosServicios = new BigDecimal(0.0);
//                }
//
//                if (nOtrosCargos.floatValue() == 0.0) {
//                    nOtrosCargos = new BigDecimal(
//                            nOtrosCargos.floatValue() +
//                                    nOtrosServicios.floatValue()).setScale(2, BigDecimal.ROUND_HALF_UP);
//                }
                otrosCargos = nOtrosCargos.toString();

                nSubTotal = new BigDecimal(nSubTotal.floatValue() - nOtrosCargos.floatValue())
                        .setScale(2, BigDecimal.ROUND_HALF_EVEN);
                subTotal = new String(nSubTotal.toString().trim());

                String detraccion = "";
                try {
                    detraccion = FunctionsXML.getTagValueHTML(PaymentTotalNodeList, "cbc:Amount");
                } catch (Exception ex) {
                    detraccion = "";
                }


                String[] refFacturaStrings = referenciaFactura.split("-");
                serieComprobante = refFacturaStrings[0];
                nroComprobante = refFacturaStrings[1];

                BillConsultPortBidingServiceLocator locator = new BillConsultPortBidingServiceLocator();
                //locator.setBillConsultServicePortEndpointAddress("https://www.sunat.gob.pe/ol-it-wsconscpegem/billConsultService");
                locator.setBillConsultServicePortEndpointAddress("https://ww1.sunat.gob.pe/ol-it-wsconscpegem/billConsultService");
                BillConsultService port = locator.getBillConsultServicePort();
                Stub stub = ((Stub) port);
                int nroComprobanteInteger = Integer.parseInt(nroComprobante + "");
                SOAPHeaderElement wsseSecurity = new SOAPHeaderElement(new PrefixedQName("http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd", "Security", "wsse"));
                MessageElement usernameToken = new MessageElement("http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd", "wsse:UsernameToken");
                MessageElement username = new MessageElement("http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd", "wsse:Username");
                MessageElement password = new MessageElement("http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd", "wsse:Password");

                username.setObjectValue(rucCliente.concat(repositoryUser));
                usernameToken.addChild(username);
                password.setObjectValue(repositoryPass);
                usernameToken.addChild(password);
                wsseSecurity.addChild(usernameToken);
                stub.setHeader(wsseSecurity);
                StatusResponse ff = port.getStatus(rucProveedor, tipoComprobante, serieComprobante, nroComprobanteInteger);

                codess = ff.getStatusCode();
                messages = ff.getStatusMessage();
                if (codess.equalsIgnoreCase("0001") || codess.equalsIgnoreCase("0009") || codess.equalsIgnoreCase("0010")) {
                    bean.setType("S");
                    bean.setMensaje(messages);
                } else {
                    bean.setType("E");
                    bean.setMensaje(messages);
                }

                String fechaEmisionString = FunctionsXML.getTagValueHTML(FacturaNodeList, "cbc:IssueDate");
                String codigoMoneda = FunctionsXML.getTagValueHTML(FacturaNodeList, "cbc:DocumentCurrencyCode");
                //Date fechaEmision = DateUtils.stringToUtilDate (fechaEmisionString);
                Date fechaEmision = DateUtils.convertStringToDate("yyyy-MM-dd", fechaEmisionString);
                if (codigoMoneda.equals(Constants.SIGLA_PERU_MONEDA)) {
                    codigoMoneda = Constants.SIGLA_PERU_MONEDA_ALTERNATIVO;
                }

                MtrSociedad mtrSociedad = this.mtrSociedadDeltaRepository.getByRuc(rucCliente);
                fechaEmisionString = DateUtils.convertDateToString("dd/MM/yyyy", fechaEmision);
                prefactura.setFechaEmisionString(fechaEmisionString);
                prefactura.setSociedad(mtrSociedad.getDescBrv());
                prefactura.setRazonSocial(mtrSociedad.getDescripcion());
                prefactura.setProveedorRuc(rucProveedor);
                prefactura.setFechaEmision(fechaEmision);
                prefactura.setReferencia(referenciaFactura);
                prefactura.setCodigoMoneda(codigoMoneda);
                prefactura.setIgv(igv);
                prefactura.setSubTotal(subTotal);
                prefactura.setTotal(montoTotal);
                prefactura.setDetraccion(detraccion);
                prefactura.setOtrosCargo(otrosCargos);
                // prefactura.setObservaciones(    );

                bean.setPrefactura(prefactura);
                if (sunatXml.exists()) {
                    sunatXml.delete();
                }
            }
            catch (Exception efac) {
                throw new Exception("Formato XML invÃ¡lido. Debe ingresar el XML proporcionado por Sunat");
            }


        } catch (IOException e) {
            messages = e.toString();
            bean.setType("EX");
            if(messages.equalsIgnoreCase("El Usuario ingresado no existe")) { // si el RUC del receptor no es uno valido, el usuario de autenticacion generado usando dicho RUC no es correcto
                messages = "El receptor no es el correcto";
            }
            bean.setMensaje(messages);
            System.out.println(e.toString());
        }catch (Exception e) {
            // TODO: handle exception
            messages = e.toString();
            bean.setType("EL");
            bean.setMensaje(messages);
            System.out.println(e.toString());
        }

        return new ResponseEntity<>(bean, HttpStatus.OK);
    }

    @ApiOperation(value = "Devuelve datos del Comprobante XML", produces = "application/json")
    @PostMapping(value = "/_leerComprobante",produces = {MediaType.APPLICATION_JSON_VALUE})
    public ResponseEntity<PrefacturaDto> LeerComprobante(@RequestParam(value = "file") MultipartFile archivoSunat){
        PrefacturaDto prefactura = new PrefacturaDto();

        try {
            File sunatXml = FunctionsXML.convert(archivoSunat);
            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
            DocumentBuilder db = dbf.newDocumentBuilder();
            Document doc = db.parse(sunatXml);

            XPath xPath = XPathFactory.newInstance().newXPath();
            String referenciaFactura = xPath.compile("/Invoice/ID").evaluate(doc);
            String igvAlt = xPath.compile("/Invoice/TaxTotal/TaxAmount").evaluate(doc);
//            String subTotal = xPath.compile("/Invoice/TaxTotal/TaxSubtotal/TaxableAmount").evaluate(doc);
            String rucProveedorAlt = xPath.compile("/Invoice/AccountingSupplierParty/Party/PartyIdentification/ID").evaluate(doc);
            String rucClienteAlt = xPath.compile("/Invoice/AccountingCustomerParty/Party/PartyIdentification/ID").evaluate(doc);

            doc.getDocumentElement().normalize();
            try {
                NodeList ProveedorNodeList = doc.getElementsByTagName("cac:AccountingSupplierParty");
                NodeList ClienteNodeList = doc.getElementsByTagName("cac:AccountingCustomerParty");
                NodeList FacturaNodeList = doc.getElementsByTagName("Invoice");
                NodeList TaxSubTotalNodeList = doc.getElementsByTagName("cac:TaxTotal");
                NodeList TaxTotalNodeList = doc.getElementsByTagName("cac:LegalMonetaryTotal");
                NodeList PaymentTotalNodeList = doc.getElementsByTagName("cac:PaymentTerms");
                NodeList InvoiceLineNodeList = doc.getElementsByTagName("cac:InvoiceLine");
                NodeList AllowanceChargeNodeList = doc.getElementsByTagName("cac:AllowanceCharge");

                String rucProveedor = FunctionsXML.getTagValueHTML(ProveedorNodeList, "cbc:ID");
                String rucCliente = FunctionsXML.getTagValueHTML(ClienteNodeList, "cbc:ID");

                if (!NumberUtils.stringIsLong(rucProveedor) && rucProveedor.length() != 11) {
                    rucProveedor = rucProveedorAlt;
                }

                if (!NumberUtils.stringIsLong(rucCliente) && rucCliente.length() != 11) {
                    rucCliente = rucClienteAlt;
                }

//            String referenciaFactura = FunctionsXML.getTagValueHTML(FacturaNodeList, "cbc:ID");
                String tipoComprobante = FunctionsXML.getTagValueHTML(FacturaNodeList, "cbc:InvoiceTypeCode");
                String montoTotal = FunctionsXML.getTagValueHTML(TaxTotalNodeList, "cbc:PayableAmount");
                String igv = "";
                String subTotal = "";
                try {
                    List<String> taxSubTotalList = FunctionsXML.getTagValueIntoTagHTML(
                            TaxSubTotalNodeList, "cbc:Name", "IGV", "cbc:TaxAmount", "cbc:TaxableAmount");
                    igv = taxSubTotalList.get(0);
                    subTotal = taxSubTotalList.get(1);
                }
                catch(Exception ex) {
                    igv = FunctionsXML.getTagValueHTML(TaxSubTotalNodeList, "cbc:TaxAmount");
                    subTotal = FunctionsXML.getTagValueHTML(TaxSubTotalNodeList, "cbc:TaxableAmount");
                }

                if (!NumberUtils.stringIsBigDecimal(igv) || ((new BigDecimal(igv).compareTo(BigDecimal.ZERO)) == 0 && (new BigDecimal(igvAlt).compareTo(BigDecimal.ZERO)) > 0)) {
                    igv = igvAlt;
                }
                subTotal = (new BigDecimal(montoTotal).compareTo(BigDecimal.ZERO) > 0) ? (new BigDecimal(montoTotal).subtract(new BigDecimal(igv))).toString() : subTotal;

                if (!NumberUtils.stringIsBigDecimal(subTotal) || ((new BigDecimal(subTotal).compareTo(BigDecimal.ZERO)) == 0)) {
                    String subTotalAlt = FunctionsXML.getTagValueHTML(TaxTotalNodeList, "cbc:LineExtensionAmount");
                    if (NumberUtils.stringIsBigDecimal(subTotalAlt)) {
                        subTotal = (new BigDecimal(subTotalAlt).compareTo(BigDecimal.ZERO) > 0) ? subTotalAlt : (new BigDecimal(montoTotal).subtract(new BigDecimal(igv))).toString();
                    }
                }

                BigDecimal nSubTotal = new BigDecimal(subTotal);
                BigDecimal nOtrosCargos = new BigDecimal(0.0);
                String otrosCargos = "";
                try {
                    otrosCargos = FunctionsXML.getTagValueHTML(TaxTotalNodeList, "cbc:ChargeTotalAmount");
                    nOtrosCargos = new BigDecimal(otrosCargos);
                }
                catch(Exception ex) {

                }

                BigDecimal nOtrosServicios = new BigDecimal(0.0);
                String otrosServicios = "";
//                try {
//                    otrosServicios = FunctionsXML.getTagValueHTML(AllowanceChargeNodeList, "cbc:Amount");
//                    nOtrosServicios = new BigDecimal(otrosServicios);
//                }
//                catch(Exception ex) {
//
//                }
//                if (nOtrosServicios.floatValue() >= nSubTotal.floatValue()) {
//                    nOtrosServicios = new BigDecimal(0.0);
//                }

//                if (nOtrosCargos.floatValue() == 0.0) {
//                    nOtrosCargos = new BigDecimal(
//                            nOtrosCargos.floatValue() +
//                                    nOtrosServicios.floatValue()).setScale(2, BigDecimal.ROUND_HALF_UP);
//                }
                otrosCargos = nOtrosCargos.toString();

                nSubTotal = new BigDecimal(nSubTotal.floatValue() - nOtrosCargos.floatValue())
                        .setScale(2, BigDecimal.ROUND_HALF_EVEN);
                subTotal = new String(nSubTotal.toString().trim());


                String[] refFacturaStrings = referenciaFactura.split("-");
                String serieComprobante = refFacturaStrings[0];
                String nroComprobante = refFacturaStrings[1];
                String razonSocial = FunctionsXML.getTagValueHTML(ProveedorNodeList, "cbc:RegistrationName");

                String detraccion = "";
                try {
                    detraccion = FunctionsXML.getTagValueHTML(PaymentTotalNodeList, "cbc:Amount");
                } catch (Exception ex) {
                    detraccion = "";
                }

                String fechaEmisionString = FunctionsXML.getTagValueHTML(FacturaNodeList, "cbc:IssueDate");
                String codigoMoneda = FunctionsXML.getTagValueHTML(FacturaNodeList, "cbc:DocumentCurrencyCode");
                //Date fechaEmision = DateUtils.stringToUtilDate (fechaEmisionString);
                Date fechaEmision = DateUtils.convertStringToDate("yyyy-MM-dd", fechaEmisionString);

                if (codigoMoneda.equals(Constants.SIGLA_PERU_MONEDA)) {
                    codigoMoneda = Constants.SIGLA_PERU_MONEDA_ALTERNATIVO;
                }
                if (StringUtils.isNotBlank(nroComprobante)) {
                    if (nroComprobante.length() < 8) {
                        nroComprobante = StringUtils.leftPad(nroComprobante, 8, "0");
                    }
                }
                String descripcion = FunctionsXML.getTagValueHTML(InvoiceLineNodeList, "cbc:Description");

                MtrSociedad mtrSociedad = this.mtrSociedadDeltaRepository.getByRuc(rucCliente);
                fechaEmisionString = DateUtils.convertDateToString("dd/MM/yyyy", fechaEmision);
                prefactura.setFechaEmisionString(fechaEmisionString);
                prefactura.setSociedad(mtrSociedad.getDescBrv());
                prefactura.setRazonSocial(mtrSociedad.getDescripcion());
                prefactura.setProveedorRuc(rucProveedor);
                prefactura.setFechaEmision(fechaEmision);
                prefactura.setReferencia(referenciaFactura);
                prefactura.setCodigoMoneda(codigoMoneda);
                prefactura.setIgv(igv);
                prefactura.setSubTotal(subTotal);
                prefactura.setTotal(montoTotal);
                prefactura.setObservaciones("RUC Cliente: " + rucCliente + " // Tipo Comprobante: " + tipoComprobante);
                prefactura.setTipoComprobante(tipoComprobante);
                prefactura.setSerieComprobante(serieComprobante);
                prefactura.setNroComprobante(nroComprobante);
                prefactura.setRazonSocial(razonSocial);
                prefactura.setConcepto(descripcion);
                prefactura.setOtrosCargo(otrosCargos);

                String cityName = "";
                String countrySubentity = "";
                String district = "";
                String direccion = "";
                try {
                    cityName = FunctionsXML.getTagValueHTML(ProveedorNodeList, "cbc:CityName");
                    countrySubentity = FunctionsXML.getTagValueHTML(ProveedorNodeList, "cbc:CountrySubentity");
                    district = FunctionsXML.getTagValueHTML(ProveedorNodeList, "cbc:District");
                    direccion = FunctionsXML.getTagValueHTML(ProveedorNodeList, "cbc:Line");
                } catch (Exception edirecx) {

                }

                prefactura.setCityName(cityName);
                prefactura.setCountrySubentity(countrySubentity);
                //prefactura.setCountrySubentityCode(countrySubentityCode);
                prefactura.setDistrict(district);
                prefactura.setDireccion(direccion);
                prefactura.setDetraccion(detraccion);
                if (sunatXml.exists()) {
                    sunatXml.delete();
                }
            }
            catch (Exception efac) {
                throw new Exception("Formato XML invÃ¡lido. Debe ingresar el XML proporcionado por Sunat");
            }

            return new ResponseEntity<>(prefactura, HttpStatus.OK);
        }
        catch (Exception e) {
            String error = Utils.obtieneMensajeErrorException(e);
            throw new RuntimeException(error);
        }
    }

    @ApiOperation(value = "Graba adjunto de Factura (TIPO FACTURA) en la carpeta Temporal", produces = "application/json")
    @PostMapping(value = "/_agregarAdjuntoTemporalTipoFactura", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<FacDocumentoAdjunto> agregarAdjuntoTemporalTipoFactura(
            @RequestParam("file") MultipartFile file) throws Exception {
        HttpHeaders headers = new HttpHeaders();
        log.debug("Agregando agregarAdjuntoTemporalTipoFactura  [" + file.getName() + " , " +
                file.getSize() + " ]");
        try {
            FacDocumentoAdjunto result = this.facFacturaDeltaService
                    .agregarAdjuntoTemporal(file, TipoFacturaAdjuntoEnum.FAC_FACTU.getEstado());
            return Optional.ofNullable(result)
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }

    @ApiOperation(value = "Graba adjunto de Factura (TIPO GUIA REMISION) en la carpeta Temporal", produces = "application/json")
    @PostMapping(value = "/_agregarAdjuntoTemporalTipoGuia", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<FacDocumentoAdjunto> agregarAdjuntoTemporalTipoGuia(
            @RequestParam("file") MultipartFile file) throws Exception {
        HttpHeaders headers = new HttpHeaders();
        log.debug("Agregando agregarAdjuntoTemporalTipoGuia  [" + file.getName() + " , " +
                file.getSize() + " ]");
        try {
            FacDocumentoAdjunto result = this.facFacturaDeltaService
                    .agregarAdjuntoTemporal(file, TipoFacturaAdjuntoEnum.FAC_GUIA.getEstado());
            return Optional.ofNullable(result)
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }

    @ApiOperation(value = "Graba adjunto de Factura (TIPO GUIA REMISION) en la carpeta Temporal", produces = "application/json")
    @GetMapping(value = "/_deleteFacturaById/{idFactura}", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<MensajeSap> _deleteFacturaById(
            @PathVariable("idFactura") Integer idFactura) throws Exception {
        MensajeSap msg = new MensajeSap("S","", "La factura se eliminÃ² correctamente");
        this.facFacturaMapper.eliminarFacturaPorId(idFactura);
        return Optional.ofNullable(msg)
                .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
    }

    @ApiOperation(value = "Graba adjunto de Factura (TIPO CDR) en la carpeta Temporal", produces = "application/json")
    @PostMapping(value = "/_agregarAdjuntoTemporalTipoCdr", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<FacDocumentoAdjunto> agregarAdjuntoTemporalTipoCdr(
            @RequestParam("file") MultipartFile file) throws Exception {
        HttpHeaders headers = new HttpHeaders();
        log.debug("Agregando agregarAdjuntoTemporalTipoCdr  [" + file.getName() + " , " +
                file.getSize() + " ]");
        try {
            FacDocumentoAdjunto result = this.facFacturaDeltaService
                    .agregarAdjuntoTemporal(file, TipoFacturaAdjuntoEnum.FAC_CDR.getEstado());
            return Optional.ofNullable(result)
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }


    @ApiOperation(value = "Graba adjunto de Factura (TIPO OTROS) en la carpeta Temporal", produces = "application/json")
    @PostMapping(value = "/_agregarAdjuntoTemporalTipoOtros", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<FacDocumentoAdjunto> agregarAdjuntoTemporalTipoOtros(
            @RequestParam("file") MultipartFile file) throws Exception {
        HttpHeaders headers = new HttpHeaders();
        log.debug("Agregando agregarAdjuntoTemporalTipoOtros  [" + file.getName() + " , " +
                file.getSize() + " ]");
        try {
            FacDocumentoAdjunto result = this.facFacturaDeltaService
                    .agregarAdjuntoTemporal(file, TipoFacturaAdjuntoEnum.FAC_OTROS.getEstado());
            return Optional.ofNullable(result)
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }


    @ApiOperation(value = "Elimina Archivo Adjunto de Factura", produces = "application/json")
    @PostMapping(value = "/_deleteAdjunto/{archivoId}", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<String> deleteAdjunto(@PathVariable("archivoId") String archivoId)
            throws Exception {
        HttpHeaders headers = new HttpHeaders();
        log.debug("Agregando deleteAdjunto: " + archivoId);
        try {
            String result = this.facFacturaDeltaService.deleteAdjunto(archivoId);
            return Optional.ofNullable(result)
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }


    @ApiOperation(value = "Devuelve Factura con sus datos hijos en base al ID de Factura ingresado", produces = "application/json")
    @GetMapping(value = "/_devuelveFactura/{facFacturaId}", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<FacFacturaDto> devuelveFactura(
            @PathVariable Integer facFacturaId
    ) throws URISyntaxException {
        HttpHeaders headers = new HttpHeaders();
        log.debug("Ingresando _devuelveFactura by: " + facFacturaId) ;
        try {
            FacFacturaDto result = this.facFacturaDeltaService.devuelveFactura(facFacturaId);
            return Optional.ofNullable(result)
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }

    @ApiOperation(value = "Graba Factura con sus datos hijos en base a los parametros ingresados", produces = "application/json")
    @PostMapping(value = "/_grabarFactura", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<FacFacturaDto> grabarFactura(@RequestBody FacFacturaEntradaDto bean) throws URISyntaxException {
        HttpHeaders headers = new HttpHeaders();
        log.debug("Ingresando grabarFactura by: " + bean.toString()) ;
        try {
            FacFacturaDto result = this.facFacturaDeltaService.grabarFactura(bean);
            this.facFacturaDeltaService.enviarEmailFactura(result);
            return Optional.ofNullable(result)
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }

    @ApiOperation(value = "Modificacion de factura y modificacion de archivos", produces = "application/json")
    @PostMapping(value = "/_modificarFactura", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<FacFactura> _modificarFactura(@RequestBody FacturaCustom custom) throws URISyntaxException {
        HttpHeaders headers = new HttpHeaders();
        log.debug("Ingresando _modificarFactura by: " + custom.toString()) ;
        try {
            //this.save(null);
            FacFactura result = this.facFacturaDeltaService.modificarFactura(custom);
            //this.facFacturaDeltaService.enviarEmailFactura(result);
            return Optional.ofNullable(result)
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }

    @ApiOperation(value = "Rechaza Factura a traves del Usuario Cupa", produces = "application/json")
    @PostMapping(value = "/_rechazarFacturaCupa", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<FacFacturaRechazoCupaSalidaDto> rechazarFacturaCupa(
            @RequestBody FacFacturaRechazoCupaEntradaDto bean
    ) throws URISyntaxException {
        HttpHeaders headers = new HttpHeaders();
        log.debug("Ingresando rechazarFacturaCupa by: " + bean) ;
        try {
            FacFacturaRechazoCupaSalidaDto result = this.facFacturaDeltaService.rechazarFacturaCupa(bean);
            this.facFacturaDeltaService.enviarEmailFacturaRechazoCupa(result);
            return Optional.ofNullable(result)
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }

    @ApiOperation(value = "Actualiza Factura en base al usuario CUPA", produces = "application/json")
    @PostMapping(value = "/_actualizarFacturaCupa", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<FacFacturaActualizarCupaSalidaDto> actualizarFacturaCupa(
            @RequestBody FacFacturaActualizarCupaEntradaDto bean) throws URISyntaxException {
        HttpHeaders headers = new HttpHeaders();
        log.debug("Ingresando actualizarFacturaCupa by: " + bean.toString()) ;
        try {
            FacFacturaActualizarCupaSalidaDto result = this.facFacturaDeltaService.grabarFacturaCupa(bean, true);
            return Optional.ofNullable(result)
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }

    @ApiOperation(value = "Graba Factura en base al usuario CUPA", produces = "application/json")
    @PostMapping(value = "/_grabarFacturaCupa", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<FacFacturaActualizarCupaSalidaDto> grabarFacturaCupa(
            @RequestBody FacFacturaActualizarCupaEntradaDto bean) throws URISyntaxException {
        HttpHeaders headers = new HttpHeaders();
        log.error("Ingresando grabarFacturaCupa by: " + bean.toString()) ;
        try {
            FacFacturaActualizarCupaSalidaDto result = this.facFacturaDeltaService.grabarFacturaCupa(bean, false);
            this.facFacturaDeltaService.enviarEmailGrabarFacturaCupa(result);
            return Optional.ofNullable(result)
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }

    @ApiOperation(value = "Graba Factura en base al usuario CUPA sin SAP", produces = "application/json")
    @PostMapping(value = "/_grabarFacturaCupaSinSAP", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<FacFacturaActualizarCupaSalidaDto> grabarFacturaCupaSinSap(
            @RequestBody FacFacturaActualizarCupaEntradaDto bean) throws URISyntaxException {
        HttpHeaders headers = new HttpHeaders();
        log.error("Ingresando _grabarFacturaCupaSinSAP by: " + bean.toString()) ;
        try {
            FacFacturaActualizarCupaSalidaDto result = this.facFacturaDeltaService.grabarFacturaCupaSinSap(bean, false);
            //this.facFacturaDeltaService.enviarEmailGrabarFacturaCupa(result);
            return Optional.ofNullable(result)
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }

    @ApiOperation(value = "Rechaza Factura a traves del Aprobador0", produces = "application/json")
    @PostMapping(value = "/_rechazarFacturaAprobador0", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<FacFacturaRechazoAprobador0SalidaDto> rechazarFacturaAprobador0(
            @RequestBody FacFacturaRechazoAprobador0EntradaDto bean
    ) throws URISyntaxException {
        HttpHeaders headers = new HttpHeaders();
        log.debug("Ingresando rechazarFacturaAprobador0 by: " + bean) ;
        try {
            FacFacturaRechazoAprobador0SalidaDto result = this.facFacturaDeltaService.rechazarFacturaAprobador0(bean);
            this.facFacturaDeltaService.enviarEmailFacturaRechazoAprobador0(result);
            return Optional.ofNullable(result)
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }

    @ApiOperation(value = "Graba Factura en base al usuario Aprobador0", produces = "application/json")
    @PostMapping(value = "/_grabarFacturaAprobador0", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<FacFacturaGrabarAprobador0SalidaDto> grabarFacturaAprobador0(
            @RequestBody FacFacturaGrabarAprobador0EntradaDto bean) throws URISyntaxException {
        HttpHeaders headers = new HttpHeaders();
        log.error("Ingresando _grabarFacturaAprobador0 by: " + bean.toString()) ;
        try {
            FacFacturaGrabarAprobador0SalidaDto result = this.facFacturaDeltaService.grabarFacturaAprobador0(bean);
            this.facFacturaDeltaService.enviarEmailFacturaAprobacionFirmanteSgte(result);
            return Optional.ofNullable(result)
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }

    @ApiOperation(value = "Rechaza Factura a traves del Firmante", produces = "application/json")
    @PostMapping(value = "/_rechazarFacturaFirmante", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<FacFacturaRechazoFirmanteSalidaDto> rechazarFacturaFirmante(
            @RequestBody FacFacturaRechazoFirmanteEntradaDto bean
    ) throws URISyntaxException {
        HttpHeaders headers = new HttpHeaders();
        log.debug("Ingresando rechazarFacturaFirmante by: " + bean) ;
        try {
            FacFacturaRechazoFirmanteSalidaDto result = this.facFacturaDeltaService.rechazarFacturaFirmante(bean);
            this.facFacturaDeltaService.enviarEmailFacturaRechazoFirmante(result);
            return Optional.ofNullable(result)
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }

    @ApiOperation(value = "Aprueba Factura a traves del Firmante", produces = "application/json")
    @PostMapping(value = "/_aprobarFacturaFirmante", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<FacFacturaAprobacionFirmanteSalidaDto> aprobarFacturaFirmante(
            @RequestBody FacFacturaAprobacionFirmanteEntradaDto bean
    ) throws URISyntaxException {
        HttpHeaders headers = new HttpHeaders();
        log.debug("Ingresando _aprobarFacturaFirmante by: " + bean) ;
        try {
            UserSession userSession = this.systemLoggedUser.getUserSession();
            FacFacturaAprobacionFirmanteSalidaDto result = this.facFacturaDeltaService.aprobarFacturaFirmante(bean, userSession);
            this.facFacturaDeltaService.enviarEmailFacturaAprobacionFirmanteSgte(result);
            return Optional.ofNullable(result)
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }

    @ApiOperation(value = "Aprobacion Masiva de Facturas a traves del Firmante", produces = "application/json")
    @PostMapping(value = "/_aprobarMasivoFacturaFirmante", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<List<FacFacturaAprobacionFirmanteSalidaDto>> aprobarMasivoFacturaFirmante(
            @RequestBody List<FacFacturaAprobacionFirmanteEntradaDto> beanLista
    ) throws URISyntaxException {
        HttpHeaders headers = new HttpHeaders();
        log.error("Ingresando _aprobarMasivoFacturaFirmante by: " + beanLista); ;
        try {
            UserSession userSession = this.systemLoggedUser.getUserSession();
            MtrUsuarioFacturacion mtrUsuarioFacturacionFirmante = this.mtrUsuarioFacturacionDeltaRepository.getByCodigoIdp(userSession.getId());
            if (!Optional.ofNullable(mtrUsuarioFacturacionFirmante).isPresent()) {
                throw new Exception("No se encontrÃ³ Firmante en la tabla Mtr_usuario_facturacion con CÃ³digo IDP " + userSession.getId());
            }

            /* Aprobacion Masiva */
            log.error("Ingresando _aprobarMasivoFacturaFirmante 01") ;
            List<CompletableFuture<FacFacturaAprobacionFirmanteSalidaDto>> completableFuturesProceso =
                    beanLista.stream().map(bean ->
                            this.facFacturaDeltaCompletableFutureService.aprobarFacturaFirmanteCompleteFuture(
                                    userSession, bean, mtrUsuarioFacturacionFirmante))
                            .collect(Collectors.toList());

            CompletableFuture
                    .allOf(completableFuturesProceso.toArray(new CompletableFuture[completableFuturesProceso.size()]));


            /* Obteniendo los resultados de la aprobacion Masiva */
            log.error("Ingresando _aprobarMasivoFacturaFirmante 02") ;
            List<FacFacturaAprobacionFirmanteSalidaDto> listaResult = new ArrayList<>();
            for (CompletableFuture<FacFacturaAprobacionFirmanteSalidaDto> beanListaFuture : completableFuturesProceso) {
                FacFacturaAprobacionFirmanteSalidaDto facFacturaAprobacionFirmanteSalidaDto = beanListaFuture.get();
                listaResult.add(facFacturaAprobacionFirmanteSalidaDto);
            }

            /* Enviando Correos */
            log.error("Ingresando _aprobarMasivoFacturaFirmante 03") ;
            List<CompletableFuture<FacFacturaAprobacionFirmanteSalidaDto>> completableFuturesEmail =
                    listaResult.stream().map(bean ->
                            this.facFacturaDeltaCompletableFutureService.enviarEmailFacturaAprobacionFirmanteSgteCompleteFuture(bean))
                            .collect(Collectors.toList());

            CompletableFuture
                    .allOf(completableFuturesEmail.toArray(new CompletableFuture[completableFuturesEmail.size()]));

            return Optional.ofNullable(listaResult)
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }



    @ApiOperation(value = "Devuelve lista de firmantes en base al ID de Factura", produces = "application/json")
    @GetMapping(value = "/_devuelveListaFirmante/{idFactura}", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<List<FacturaListaFirmantesDto>> devuelveListaFirmante(@PathVariable("idFactura") Integer idFactura) throws URISyntaxException {
        HttpHeaders headers = new HttpHeaders();
        log.debug("Ingresando devuelveListaFirmante by: " + idFactura);
        try {
            List<FacturaListaFirmantesDto> result = this.facFacturaDeltaService.devuelveListaFirmantes(idFactura);
            return Optional.ofNullable(result).map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        } catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }

    @ApiOperation(value = "Devuelve lista de posibles firmantes en base al ID de la Estrategia", produces = "application/json")
    @GetMapping(value = "/devuelveListaFirmantesEstrategia/{mtrEstrategiaId}", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<List<MtrUsuarioFirmanteEstrategiaDto>> devuelveListaFirmantesEstrategia(
            @PathVariable("mtrEstrategiaId") Integer mtrEstrategiaId) throws URISyntaxException {
        HttpHeaders headers = new HttpHeaders();
        log.debug("Ingresando devuelveListaFirmantesEstrategia by: " + mtrEstrategiaId);
        try {
            List<MtrUsuarioFirmanteEstrategiaDto> result = this.facFacturaDeltaService.devuelveListaFirmantesEstrategia(mtrEstrategiaId);
            return Optional.ofNullable(result).map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        } catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }

    @ApiOperation(value = "Graba Aprobacion/Rechazo en Adjuntos Factura", produces = "application/json")
    @PostMapping(value = "/_grabarFacturaValidacionAdjunto", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<FacFacturaValidarAdjuntoSalidaDto> grabarFacturaValidacionAdjunto(
            @RequestBody FacFacturaValidarAdjuntoEntradaDto bean
    ) throws URISyntaxException {
        HttpHeaders headers = new HttpHeaders();
        log.debug("Ingresando grabarFacturaValidacionAdjunto by: " + bean) ;
        try {
            FacFacturaValidarAdjuntoSalidaDto result = this.facFacturaDeltaService.grabarFacturaValidacionAdjunto(bean);
            return Optional.ofNullable(result)
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }

    @ApiOperation(value = "Graba Aprobacion/Rechazo en Adjuntos una lista de Facturas", produces = "application/json")
    @PostMapping(value = "/_grabarFacturaValidacionAdjuntoLista", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<List<FacFacturaValidarAdjuntoSalidaDto>> grabarFacturaValidacionAdjuntoLista(
            @RequestBody List<FacFacturaValidarAdjuntoEntradaDto> beanLista
    ) throws URISyntaxException {
        HttpHeaders headers = new HttpHeaders();
        log.debug("Ingresando grabarFacturaValidacionAdjuntoLista by: " + beanLista) ;
        try {
            List<FacFacturaValidarAdjuntoSalidaDto> result = this.facFacturaDeltaService.grabarFacturaValidacionAdjuntoLista(beanLista);
            return Optional.ofNullable(result)
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }

    @ApiOperation(value = "Devuelve lista de registros de tipo FacFactura pendientes Aprobar/Rechazar para el Aprobador0 logueado", produces = "application/json")
    @PostMapping(value = "/_findFacturaAprobarRechazarAprobador0", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<List<FacFactura>> findFacturaAprobarRechazarAprobador0() throws URISyntaxException {
        HttpHeaders headers = new HttpHeaders();
        log.debug("Ingresando _findFacturaAprobarRechazarAprobador0 by:");
        try {
            List<FacFactura> result = this.facFacturaDeltaService.findFacturaAprobarRechazarAprobador0();
            return Optional.ofNullable(result).map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        } catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }

    @ApiOperation(value = "Devuelve lista de registros de tipo FacFactura pendientes de Firma (Aprobar/Rechazar) para el Firmante logueado", produces = "application/json")
    @PostMapping(value = "/_findFacturaAprobarRechazarFirmante", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<List<FacFactura>> findFacturaAprobarRechazarFirmante() throws URISyntaxException {
        HttpHeaders headers = new HttpHeaders();
        log.debug("Ingresando _findFacturaAprobarRechazarFirmante by:");
        try {
            List<FacFactura> result = this.facFacturaDeltaService.findFacturaAprobarRechazarFirmante();
            return Optional.ofNullable(result).map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        } catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }



    @ApiOperation(value = "Devuelve correlativo Factura para adjuntos OTROS mayores a 5MB", produces = "application/json")
    @GetMapping(value = "/_devuelveCorrelativoAdjuntoOtros5MB/{tamanno}", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<Integer> _devuelveCorrelativoAdjuntoOtros5MB(
            @PathVariable BigDecimal tamanno) throws URISyntaxException {
        HttpHeaders headers = new HttpHeaders();
        log.debug("Ingresando _devuelveCorrelativoAdjuntoOtros5MB by:" + tamanno);
        try {
            Integer result = this.facFacturaDeltaService.devuelveCorrelativoAdjuntoOtros5MB(tamanno);
            return Optional.ofNullable(result).map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        } catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }


    @ApiOperation(value = "Devuelve lista de registros de tipo FacFactura en base al Proveedor ingresados en forma Paginada", produces = "application/json")
    @PostMapping(value = "/_findCondicionProveedorPaginated", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<PageResponse<FacFactura>> findCondicionProveedorPaginated(
            @RequestBody FacFacturaResponse bean, BindingResult bindingResult) throws URISyntaxException {
        BindingErrorsResponse errors = new BindingErrorsResponse();
        HttpHeaders headers = new HttpHeaders();
        if (bindingResult.hasErrors()) {
            String errorDevuelve = this.devuelveErrorHeaders(bindingResult, errors);
            if (this.devuelveRuntimeException) {
                throw new RuntimeException(errorDevuelve);
            }
            headers.add("errors", errorDevuelve);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
        if (!Optional.ofNullable(bean.getPageRequest()).isPresent()) {
            String errorDevuelve = "Debe ingresar Bean de PaginaciÃ³n (PageRequest)";
            if (this.devuelveRuntimeException) {
                throw new RuntimeException(errorDevuelve);
            }
            headers.add("errors", errorDevuelve);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
        PageRequest pageRequest = bean.getPageRequest().toPageRequest();
        log.debug("Ingresando findCondicionProveedorPaginated by:" + bean.toString());
        try {
            PageResponse<FacFactura> result = this.facFacturaDeltaService.findCondicionProveedorPaginated(bean, pageRequest);
            return Optional.ofNullable(result).map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        } catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }

    @ApiOperation(value = "Devuelve lista de registros de tipo FacFactura en base al Proveedor ingresados en forma Paginada (Registro de Facturas)", produces = "application/json")
    @PostMapping(value = "/_findCondicionProveedorRegistroPaginated", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<PageResponse<FacFactura>> findCondicionProveedorRegistroPaginated(
            @RequestBody FacFacturaResponse bean, BindingResult bindingResult) throws URISyntaxException {
        BindingErrorsResponse errors = new BindingErrorsResponse();
        HttpHeaders headers = new HttpHeaders();
        if (bindingResult.hasErrors()) {
            String errorDevuelve = this.devuelveErrorHeaders(bindingResult, errors);
            if (this.devuelveRuntimeException) {
                throw new RuntimeException(errorDevuelve);
            }
            headers.add("errors", errorDevuelve);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
        if (!Optional.ofNullable(bean.getPageRequest()).isPresent()) {
            String errorDevuelve = "Debe ingresar Bean de PaginaciÃ³n (PageRequest)";
            if (this.devuelveRuntimeException) {
                throw new RuntimeException(errorDevuelve);
            }
            headers.add("errors", errorDevuelve);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
        PageRequest pageRequest = bean.getPageRequest().toPageRequest();
        log.debug("Ingresando _findCondicionProveedorRegistroPaginated by:" + bean.toString());
        try {
            PageResponse<FacFactura> result = this.facFacturaDeltaService.findCondicionProveedorRegistroPaginated(bean, pageRequest);
            return Optional.ofNullable(result).map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        } catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }

    @ApiOperation(value = "Devuelve lista de registros de tipo FacFactura en base al Proveedor ingresados en forma Paginada (PublicaciÃ³n de Facturas)", produces = "application/json")
    @PostMapping(value = "/_findCondicionProveedorPublicacionPaginated", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<PageResponse<FacFactura>> findCondicionProveedorPublicacionPaginated(
            @RequestBody FacFacturaResponse bean, BindingResult bindingResult) throws URISyntaxException {
        BindingErrorsResponse errors = new BindingErrorsResponse();
        HttpHeaders headers = new HttpHeaders();
        if (bindingResult.hasErrors()) {
            String errorDevuelve = this.devuelveErrorHeaders(bindingResult, errors);
            if (this.devuelveRuntimeException) {
                throw new RuntimeException(errorDevuelve);
            }
            headers.add("errors", errorDevuelve);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
        if (!Optional.ofNullable(bean.getPageRequest()).isPresent()) {
            String errorDevuelve = "Debe ingresar Bean de PaginaciÃ³n (PageRequest)";
            if (this.devuelveRuntimeException) {
                throw new RuntimeException(errorDevuelve);
            }
            headers.add("errors", errorDevuelve);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
        PageRequest pageRequest = bean.getPageRequest().toPageRequest();
        log.debug("Ingresando _findCondicionProveedorPublicacionPaginated by:" + bean.toString());
        try {
            PageResponse<FacFactura> result = this.facFacturaDeltaService.findCondicionProveedorPublicacionPaginated(bean, pageRequest);
            return Optional.ofNullable(result).map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        } catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }

    @ApiOperation(value = "Devuelve lista de registros de tipo FacFactura en forma Paginada (PublicaciÃ³n de Facturas)", produces = "application/json")
    @PostMapping(value = "/_findCondicionPublicacionPaginated", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<PageResponse<FacFactura>> findCondicionPublicacionPaginated(
            @RequestBody FacFacturaResponse bean, BindingResult bindingResult) throws URISyntaxException {
        BindingErrorsResponse errors = new BindingErrorsResponse();
        HttpHeaders headers = new HttpHeaders();
        if (bindingResult.hasErrors()) {
            String errorDevuelve = this.devuelveErrorHeaders(bindingResult, errors);
            if (this.devuelveRuntimeException) {
                throw new RuntimeException(errorDevuelve);
            }
            headers.add("errors", errorDevuelve);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
        if (!Optional.ofNullable(bean.getPageRequest()).isPresent()) {
            String errorDevuelve = "Debe ingresar Bean de PaginaciÃ³n (PageRequest)";
            if (this.devuelveRuntimeException) {
                throw new RuntimeException(errorDevuelve);
            }
            headers.add("errors", errorDevuelve);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
        PageRequest pageRequest = bean.getPageRequest().toPageRequest();
        log.debug("Ingresando findCondicionPublicacionPaginated by:" + bean.toString());
        try {
            PageResponse<FacFactura> result = this.facFacturaDeltaService.findCondicionPublicacionPaginated(bean, pageRequest);
            return Optional.ofNullable(result).map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        } catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }

    @ApiOperation(value = "Devuelve lista de registros de tipo FacFactura en forma Paginada (PublicaciÃ³n de Facturas)", produces = "application/json")
    @PostMapping(value = "/_findCondicionPublicacionConAdjuntoPaginated", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<PageResponse<FacFacturaAndAdjuntoFacFactuDto>> findCondicionPublicacionConAdjuntoPaginated(
            @RequestBody FacFacturaResponse bean, BindingResult bindingResult) throws URISyntaxException {
        BindingErrorsResponse errors = new BindingErrorsResponse();
        HttpHeaders headers = new HttpHeaders();
        if (bindingResult.hasErrors()) {
            String errorDevuelve = this.devuelveErrorHeaders(bindingResult, errors);
            if (this.devuelveRuntimeException) {
                throw new RuntimeException(errorDevuelve);
            }
            headers.add("errors", errorDevuelve);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
        if (!Optional.ofNullable(bean.getPageRequest()).isPresent()) {
            String errorDevuelve = "Debe ingresar Bean de PaginaciÃ³n (PageRequest)";
            if (this.devuelveRuntimeException) {
                throw new RuntimeException(errorDevuelve);
            }
            headers.add("errors", errorDevuelve);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
        PageRequest pageRequest = bean.getPageRequest().toPageRequest();
        log.debug("Ingresando findCondicionPublicacionPaginated by:" + bean.toString());
        try {
            PageResponse<FacFacturaAndAdjuntoFacFactuDto> result = this.facFacturaDeltaService.
                    findCondicionPublicacionConAdjuntoPaginated(bean, pageRequest);
            return Optional.ofNullable(result).map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        } catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }


    @ApiOperation(value = "Devuelve lista de registros de tipo FacFactura ingresados en forma Paginada (Facturas en estado de CUPA)", produces = "application/json")
    @PostMapping(value = "/_findCondicionCupaPaginated", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<PageResponse<FacFactura>> findCondicionCupaPaginated(
            @RequestBody FacFacturaResponse bean, BindingResult bindingResult) throws URISyntaxException {
        BindingErrorsResponse errors = new BindingErrorsResponse();
        HttpHeaders headers = new HttpHeaders();
        if (bindingResult.hasErrors()) {
            String errorDevuelve = this.devuelveErrorHeaders(bindingResult, errors);
            if (this.devuelveRuntimeException) {
                throw new RuntimeException(errorDevuelve);
            }
            headers.add("errors", errorDevuelve);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
        if (!Optional.ofNullable(bean.getPageRequest()).isPresent()) {
            String errorDevuelve = "Debe ingresar Bean de PaginaciÃ³n (PageRequest)";
            if (this.devuelveRuntimeException) {
                throw new RuntimeException(errorDevuelve);
            }
            headers.add("errors", errorDevuelve);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
        PageRequest pageRequest = bean.getPageRequest().toPageRequest();
        log.debug("Ingresando findCondicionCupaPaginated by:" + bean.toString());
        try {
            PageResponse<FacFactura> result = this.facFacturaDeltaService.findCondicionCupaPaginated(bean, pageRequest);
            return Optional.ofNullable(result).map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        } catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }

    @ApiOperation(value = "Devuelve lista de registros de tipo FacFactura ingresados en forma Paginada (Facturas para Validacion de Adjuntos)", produces = "application/json")
    @PostMapping(value = "/_findCondicionValidacionAdjuntosPaginated", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<PageResponse<FacFactura>> findCondicionValidacionAdjuntosPaginated(
            @RequestBody FacFacturaResponse bean, BindingResult bindingResult) throws URISyntaxException {
        BindingErrorsResponse errors = new BindingErrorsResponse();
        HttpHeaders headers = new HttpHeaders();
        if (bindingResult.hasErrors()) {
            String errorDevuelve = this.devuelveErrorHeaders(bindingResult, errors);
            if (this.devuelveRuntimeException) {
                throw new RuntimeException(errorDevuelve);
            }
            headers.add("errors", errorDevuelve);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
        if (!Optional.ofNullable(bean.getPageRequest()).isPresent()) {
            String errorDevuelve = "Debe ingresar Bean de PaginaciÃ³n (PageRequest)";
            if (this.devuelveRuntimeException) {
                throw new RuntimeException(errorDevuelve);
            }
            headers.add("errors", errorDevuelve);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
        PageRequest pageRequest = bean.getPageRequest().toPageRequest();
        log.debug("Ingresando findCondicionValidacionAdjuntosPaginated by:" + bean.toString());
        try {
            PageResponse<FacFactura> result = this.facFacturaDeltaService.findCondicionValidacionAdjuntosPaginated(bean, pageRequest);
            return Optional.ofNullable(result).map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        } catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }



    @ApiOperation(value = "Devuelve lista de registros de tipo FacFactura en base al Proveedor y en base a los parÃ¡metros ingresados", produces = "application/json")
    @PostMapping(value = "/_findProveedor", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<List<FacFactura>> findProveedor(@RequestBody FacFactura bean, BindingResult bindingResult) throws URISyntaxException {
        BindingErrorsResponse errors = new BindingErrorsResponse();
        HttpHeaders headers = new HttpHeaders();
        if (bindingResult.hasErrors()) {
            String errorDevuelve = this.devuelveErrorHeaders(bindingResult, errors);
            if (this.devuelveRuntimeException) {
                throw new RuntimeException(errorDevuelve);
            }
            headers.add("errors", errorDevuelve);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
        log.debug("Ingresando findProveedor by:" + bean.toString());
        try {
            return Optional.ofNullable(this.facFacturaDeltaService.findProveedor(bean))
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }

    @ApiOperation(value = "Devuelve lista de registros de tipo FacFactura en base al Proveedor y en base a los parÃ¡metros y condiciones ingresados ", produces = "application/json")
    @PostMapping(value = "/_findCondicionProveedor", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<List<FacFactura>> findCondicionProveedor(@RequestBody FacFacturaResponse bean, BindingResult bindingResult) throws URISyntaxException {
        BindingErrorsResponse errors = new BindingErrorsResponse();
        HttpHeaders headers = new HttpHeaders();
        if (bindingResult.hasErrors()) {
            String errorDevuelve = this.devuelveErrorHeaders(bindingResult, errors);
            if (this.devuelveRuntimeException) {
                throw new RuntimeException(errorDevuelve);
            }
            headers.add("errors", errorDevuelve);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
        log.debug("Ingresando findCondicionProveedor by:" + bean.toString());
        try {
            return Optional.ofNullable(this.facFacturaDeltaService.findCondicionProveedor(bean))
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }



    @ApiOperation(value = "Listado criterio facFactura", produces = "application/json")
    @RequestMapping(value = "/listCriterioFacFactura", method = RequestMethod.POST, headers = "Accept=application/json")
    ResponseEntity<List<FacFactura>> listCriterioFacFactura(@RequestBody FacFactura facFactura)
            throws Exception {
        return Optional.of(new ResponseEntity<List<FacFactura>>(
                this.facFacturaDeltaService.find(facFactura),
                HttpStatus.OK)).orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
    }

    @ApiOperation(value = "Contabilizacion Documento Preliminar", produces = "application/json")
    @RequestMapping(value = "/contabilizarDocumentoPreliminar", method = RequestMethod.POST, headers = "Accept=application/json")
    ResponseEntity<ContabilizacionPreliminarOutput> contabilizarDocumentoPreliminar(@RequestBody ContabilizacionPreliminarInput input)
            throws Exception {
        return Optional.of(new ResponseEntity<ContabilizacionPreliminarOutput>(
                this.sapRfcDeltaService.contabilizarDocumentoPreliminar(input.getNroDocumento(), input.getSociedad(), input.getAnnio(), input.getFlagConta(), input.getFlagAnula()),
                HttpStatus.OK)).orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));

    }





    @RequestMapping(value = "/adjunto/{tipoAdjunto}", method = RequestMethod.POST, produces = {
            MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE})
    public ResponseEntity<?> facturaAdjunto(
            @PathVariable("tipoAdjunto") String tipoAdjunto,
            @RequestParam("file") MultipartFile file
    ) throws Exception {
        log.debug("facturaAdjunto: [" + file.getName() + " , " +
                file.getSize() + " ]");
        return Optional.ofNullable(this.facFacturaDeltaService.facturaAdjunto(file, tipoAdjunto))
                .map(oj -> {
                    Map response = new HashMap<>();
                    response.put("data", oj);
                    return response;
                })
                .map(response -> new ResponseEntity<>(response, HttpStatus.OK))
                .orElse(new ResponseEntity<>(HttpStatus.NOT_FOUND));
    }

    @RequestMapping(value = "/deleteOneFile/{fileID}", method = RequestMethod.POST, produces = {
            MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE})
    public ResponseEntity<?> deleteOneFile(@PathVariable("fileID") String fileID) {
        HttpHeaders headers = new HttpHeaders();
        try {
            return Optional.of(new ResponseEntity<List<String>>(
                    this.facFacturaDeltaService.deleteOneFile(fileID),
                    HttpStatus.OK)).orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }


    @RequestMapping(value = "/factura/listaAdjuntos/{facturaID}", method = RequestMethod.POST, produces = {
            MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE})
    public ResponseEntity<?> listaAdjuntos(@PathVariable("facturaID") Integer facturaID) {
        return Optional.of(new ResponseEntity<List<FacDocumentoAdjunto>>(
                this.facFacturaDeltaService.listaAdjuntos(facturaID),
                HttpStatus.OK)).orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
    }

    @RequestMapping(value = "/factura/deleteAllFilesCMIS", method = RequestMethod.POST, produces = {
            MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE})
    public ResponseEntity<?> deleteAllFilesCMIS() {
        return Optional.of(new ResponseEntity<List<CmisFile>>(
                this.facFacturaDeltaService.deleteAllFilesCMIS(),
                HttpStatus.OK)).orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
    }

    @ApiOperation(value = "Genera Reporte Pdf Factura", produces = "application/pdf")
    @GetMapping(value = "/_generarReportePdf/{facturaId}", produces = { MediaType.APPLICATION_PDF_VALUE })
    public ResponseEntity<ByteArrayResource> generarReportePdf(@PathVariable Integer facturaId)  {
        try
        {
            UserSession userSession = this.systemLoggedUser.getUserSession();
            ByteArrayResource byteArrayResource = this.facFacturaDeltaService.generarReportePdf(facturaId, userSession.getId());

            HttpHeaders headers = new HttpHeaders();
            headers.add("Content-Disposition", "inline; filename=ReporteFactura.pdf");
            return ResponseEntity
                    .ok()
                    .headers(headers)
                    .contentType(MediaType.APPLICATION_PDF)
                    .body(byteArrayResource);
        }
        catch (Exception e) {
            String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
            throw new RuntimeException(error);
        }
    }

    @ApiOperation(value = "Genera Reporte Pdf Constancia Registro Correlativo Factura", produces = "application/pdf")
    @GetMapping(value = "/_generarReporteConstanciaPdf/{proveedorId}/{numCorrelativo}", produces = { MediaType.APPLICATION_PDF_VALUE })
    public ResponseEntity<ByteArrayResource> generarReporteConstanciaPdf(@PathVariable Integer proveedorId, @PathVariable Integer numCorrelativo)  {
        try
        {
            UserSession userSession = this.systemLoggedUser.getUserSession();
            ByteArrayResource byteArrayResource = this.facFacturaDeltaService.generarReporteConstanciaPdf(proveedorId, numCorrelativo);

            HttpHeaders headers = new HttpHeaders();
            headers.add("Content-Disposition", "inline; filename=reporteConstancia.pdf");
            return ResponseEntity
                    .ok()
                    .headers(headers)
                    .contentType(MediaType.APPLICATION_PDF)
                    .body(byteArrayResource);
        }
        catch (Exception e) {
            String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
            throw new RuntimeException(error);
        }
    }

    @ApiOperation(value = "Listado criterio facFactura", produces = "application/json")
    @RequestMapping(value = "/realizarPreregistroFactura/{facturaId}", method = RequestMethod.GET, headers = "Accept=application/json")
    ResponseEntity<List<MensajeHistorialSap>> realizarPreregistroFactura(@PathVariable Integer facturaId)
            throws Exception {

        Optional<FacFactura> optionalFacFactura = this.facFacturaDeltaRepository.findById(facturaId);
        if (!optionalFacFactura.isPresent()) {
            throw new Exception("No se encontrÃ³ Factura con ID: " + facturaId);
        }
        return Optional.of(new ResponseEntity<List<MensajeHistorialSap>>(
                this.facFacturaDeltaService.realizarPreregistroFactura(optionalFacFactura.get(), optionalFacFactura.get().getMontoIgv()),
                HttpStatus.OK)).orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
    }

    @ApiOperation(value = "Genera Excel XLSX de registros por Factura", produces = "application/vnd.ms-excel")
    @GetMapping(value = "/_downloadExcelporFiltroNew/{tipoFactura}/{serieFactura}/{numeroFactura}/{numeroFacturaSap}/{ruc}/{razonSocial}/{mtrSociedadId}/{fechaFacturaIni}/{fechaFacturaFin}/{fechaEmisionIni}/{fechaEmisionFin}/{fechaCreacionIni}/{fechaCreacionFin}/{mtrEstadoId}/{indicadorConCertificado}/{esProveedorExtranjero}/{listaCodigoAcreedor}/{listaMtrEstadoId}", produces = { MediaType.APPLICATION_OCTET_STREAM_VALUE })
    public ResponseEntity<?> downloadCompleteExcelNewSXLSX(
            @PathVariable String tipoFactura,
            @PathVariable String serieFactura,
            @PathVariable String numeroFactura,
            @PathVariable String numeroFacturaSap,
            @PathVariable String ruc,
            @PathVariable String razonSocial,
            @PathVariable Integer mtrSociedadId,
            @PathVariable String fechaFacturaIni,
            @PathVariable String fechaFacturaFin,
            @PathVariable String fechaEmisionIni,
            @PathVariable String fechaEmisionFin,
            @PathVariable String fechaCreacionIni,
            @PathVariable String fechaCreacionFin,
            @PathVariable Integer mtrEstadoId,
            @PathVariable String indicadorConCertificado,
            @PathVariable String esProveedorExtranjero,
            @PathVariable String listaCodigoAcreedor,
            @PathVariable String listaMtrEstadoId,
            HttpServletResponse response) {

        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd_hh_mm_ss");
        String nombreArchivo = this.setObtenerNombreArchivoExcel();
        String excelFileName = nombreArchivo + "_" + formatter.format(LocalDateTime.now()) + ".xlsx";

        try {
            FacFactura facFactura = new FacFactura();
            if  (StringUtils.isNotBlank(indicadorConCertificado) && !indicadorConCertificado.equalsIgnoreCase("XYZ")) {
                facFactura.setIndicadorConCertificado(indicadorConCertificado);
            }
            if  (StringUtils.isNotBlank(esProveedorExtranjero) && !esProveedorExtranjero.equalsIgnoreCase("XYZ")) {
                facFactura.setEsProveedorExtranjero(esProveedorExtranjero);
            }
            if  (StringUtils.isNotBlank(listaCodigoAcreedor) && !listaCodigoAcreedor.equalsIgnoreCase("XYZ")) {
                String[] lista = StringUtils.split(listaCodigoAcreedor,'-');
                if (lista != null && lista.length > 0) {
                    List<String> listaFinal = new ArrayList<>();
                    for (String codigo : lista) {
                        listaFinal.add(codigo);
                    }
                    facFactura.setListaCodigoAcreedor(listaFinal);
                }
            }
            if  (StringUtils.isNotBlank(listaMtrEstadoId) && !listaMtrEstadoId.equalsIgnoreCase("XYZ")) {
                String[] lista = StringUtils.split(listaMtrEstadoId,'-');
                if (lista != null && lista.length > 0) {
                    List<Integer> listaFinal = new ArrayList<>();
                    for (String codigo : lista) {
                        listaFinal.add(new Integer(codigo));
                    }
                    facFactura.setMtrEstadoLista(listaFinal);
                }
            }

            if  (StringUtils.isNotBlank(tipoFactura) && !tipoFactura.equalsIgnoreCase("XYZ")) {
                facFactura.setTipoFactura(tipoFactura);
            }
            if  (StringUtils.isNotBlank(serieFactura) && !serieFactura.equalsIgnoreCase("XYZ")) {
                facFactura.setSerieFactura(serieFactura);
            }
            if  (StringUtils.isNotBlank(numeroFactura) && !numeroFactura.equalsIgnoreCase("XYZ")) {
                facFactura.setNumeroFactura(numeroFactura);
            }
            if  (StringUtils.isNotBlank(numeroFacturaSap) && !numeroFacturaSap.equalsIgnoreCase("XYZ")) {
                facFactura.setNumeroFacturaSap(numeroFacturaSap);
            }
            if  ((StringUtils.isNotBlank(ruc) && !ruc.equalsIgnoreCase("XYZ"))||
                    (StringUtils.isNotBlank(razonSocial) && !razonSocial.equalsIgnoreCase("XYZ"))) {
                MtrProveedor mtrProveedor = new MtrProveedor();
                if  (StringUtils.isNotBlank(ruc) && !ruc.equalsIgnoreCase("XYZ")) {
                    mtrProveedor.setRuc(ruc);
                }
                if  (StringUtils.isNotBlank(razonSocial) && !razonSocial.equalsIgnoreCase("XYZ")) {
                    mtrProveedor.setRazonSocial(razonSocial);
                }
                facFactura.setMtrProveedor(mtrProveedor);
            }

            if  (mtrSociedadId != 0) {
                MtrSociedad mtrSociedad = new MtrSociedad();
                mtrSociedad.setId(mtrSociedadId);
                facFactura.setMtrSociedad(mtrSociedad);
            }

            if  (StringUtils.isNotBlank(fechaFacturaIni) && !fechaFacturaIni.equalsIgnoreCase("XYZ")) {
                Date fecha = DateUtils.convertStringToDate("yyyyMMdd", fechaFacturaIni);
                String sFecha = DateUtils.convertDateToString("dd/MM/yyyy", fecha);
                facFactura.setFechaFacturaIni(sFecha);
            }
            if  (StringUtils.isNotBlank(fechaFacturaFin) && !fechaFacturaFin.equalsIgnoreCase("XYZ")) {
                Date fecha = DateUtils.convertStringToDate("yyyyMMdd", fechaFacturaFin);
                String sFecha = DateUtils.convertDateToString("dd/MM/yyyy", fecha);
                facFactura.setFechaFacturaFin(sFecha);
            }
            if  (StringUtils.isNotBlank(fechaEmisionIni) && !fechaEmisionIni.equalsIgnoreCase("XYZ")) {
                Date fecha = DateUtils.convertStringToDate("yyyyMMdd", fechaEmisionIni);
                String sFecha = DateUtils.convertDateToString("dd/MM/yyyy", fecha);
                facFactura.setFechaEmisionIni(sFecha);
            }
            if  (StringUtils.isNotBlank(fechaEmisionFin) && !fechaEmisionFin.equalsIgnoreCase("XYZ")) {
                Date fecha = DateUtils.convertStringToDate("yyyyMMdd", fechaEmisionFin);
                String sFecha = DateUtils.convertDateToString("dd/MM/yyyy", fecha);
                facFactura.setFechaEmisionFin(sFecha);
            }
            if  (StringUtils.isNotBlank(fechaCreacionIni) && !fechaCreacionIni.equalsIgnoreCase("XYZ")) {
                Date fecha = DateUtils.convertStringToDate("yyyyMMdd", fechaCreacionIni);
                String sFecha = DateUtils.convertDateToString("dd/MM/yyyy", fecha);
                facFactura.setFechaCreacionIni(sFecha);
            }
            if  (StringUtils.isNotBlank(fechaCreacionFin) && !fechaCreacionFin.equalsIgnoreCase("XYZ")) {
                Date fecha = DateUtils.convertStringToDate("yyyyMMdd", fechaCreacionFin);
                String sFecha = DateUtils.convertDateToString("dd/MM/yyyy", fecha);
                facFactura.setFechaCreacionFin(sFecha);
            }
            if  (mtrEstadoId != 0) {
                MtrEstado mtrEstado = new MtrEstado();
                mtrEstado.setId(mtrEstadoId);
                facFactura.setMtrEstado(mtrEstado);
            }


            SXSSFWorkbook book = this.facFacturaDeltaService.downloadExcelporFiltro(facFactura);
            ByteArrayOutputStream outByteStream;
            byte[] outArray;
            outByteStream = new ByteArrayOutputStream();
            book.write(outByteStream);
            outArray = outByteStream.toByteArray();
            response.setContentLength(outArray.length);
            response.setHeader("Expires:", "0"); // eliminates browser caching
            response.setHeader("Content-Disposition", "attachment; filename=" + excelFileName);
            OutputStream outStream = response.getOutputStream();
            outStream.write(outArray);

            book.dispose();
            book.close();

            outStream.flush();

        } catch (Exception e) {
            String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
            e.printStackTrace();
            throw new RuntimeException(error);
        }

        return new ResponseEntity<>(HttpStatus.OK);
    }

    @ApiOperation(value = "Genera Excel XLSX de registros por Factura", produces = "application/vnd.ms-excel")
    @GetMapping(value = "/_downloadExcelporFiltro/{tipoFactura}/{serieFactura}/{numeroFactura}/{numeroFacturaSap}/{ruc}/{razonSocial}/{mtrSociedadId}/{fechaFacturaIni}/{fechaFacturaFin}/{fechaEmisionIni}/{fechaEmisionFin}/{fechaCreacionIni}/{fechaCreacionFin}/{mtrEstadoId}/{indicadorConCertificado}/{esProveedorExtranjero}/{listaCodigoAcreedor}/{listaMtrEstadoId}", produces = { MediaType.APPLICATION_OCTET_STREAM_VALUE })
    public ResponseEntity<?> downloadCompleteExcelSXLSX(
            @PathVariable String tipoFactura,
            @PathVariable String serieFactura,
            @PathVariable String numeroFactura,
            @PathVariable String numeroFacturaSap,
            @PathVariable String ruc,
            @PathVariable String razonSocial,
            @PathVariable Integer mtrSociedadId,
            @PathVariable String fechaFacturaIni,
            @PathVariable String fechaFacturaFin,
            @PathVariable String fechaEmisionIni,
            @PathVariable String fechaEmisionFin,
            @PathVariable String fechaCreacionIni,
            @PathVariable String fechaCreacionFin,
            @PathVariable Integer mtrEstadoId,
            @PathVariable String indicadorConCertificado,
            @PathVariable String esProveedorExtranjero,
            @PathVariable String listaCodigoAcreedor,
            @PathVariable String listaMtrEstadoId,
            HttpServletResponse response) {

        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd_hh_mm_ss");
        String nombreArchivo = this.setObtenerNombreArchivoExcel();
        String excelFileName = nombreArchivo + "_" + formatter.format(LocalDateTime.now()) + ".xlsx";

        try {
            FacFactura facFactura = new FacFactura();
            if  (StringUtils.isNotBlank(indicadorConCertificado)) {
                facFactura.setIndicadorConCertificado(indicadorConCertificado);
            }
            if  (StringUtils.isNotBlank(esProveedorExtranjero)) {
                facFactura.setEsProveedorExtranjero(esProveedorExtranjero);
            }
            if  (StringUtils.isNotBlank(listaCodigoAcreedor)) {
                String[] lista = StringUtils.split(listaCodigoAcreedor,'-');
                if (lista != null && lista.length > 0) {
                    List<String> listaFinal = new ArrayList<>();
                    for (String codigo : lista) {
                        listaFinal.add(codigo);
                    }
                    facFactura.setListaCodigoAcreedor(listaFinal);
                }
            }
            if  (StringUtils.isNotBlank(listaMtrEstadoId)) {
                String[] lista = StringUtils.split(listaMtrEstadoId,'-');
                if (lista != null && lista.length > 0) {
                    List<Integer> listaFinal = new ArrayList<>();
                    for (String codigo : lista) {
                        listaFinal.add(new Integer(codigo));
                    }
                    facFactura.setMtrEstadoLista(listaFinal);
                }
            }

            if  (StringUtils.isNotBlank(tipoFactura)) {
                facFactura.setTipoFactura(tipoFactura);
            }
            if  (StringUtils.isNotBlank(tipoFactura)) {
                facFactura.setSerieFactura(serieFactura);
            }
            if  (StringUtils.isNotBlank(numeroFactura)) {
                facFactura.setNumeroFactura(numeroFactura);
            }
            if  (StringUtils.isNotBlank(numeroFacturaSap)) {
                facFactura.setNumeroFacturaSap(numeroFacturaSap);
            }
            if  (StringUtils.isNotBlank(ruc) || StringUtils.isNotBlank(razonSocial)) {
                MtrProveedor mtrProveedor = new MtrProveedor();
                if  (StringUtils.isNotBlank(ruc)) {
                    mtrProveedor.setRuc(ruc);
                }
                if  (StringUtils.isNotBlank(razonSocial)) {
                    mtrProveedor.setRazonSocial(razonSocial);
                }
                facFactura.setMtrProveedor(mtrProveedor);
            }

            if  (mtrSociedadId != 0) {
                MtrSociedad mtrSociedad = new MtrSociedad();
                mtrSociedad.setId(mtrSociedadId);
                facFactura.setMtrSociedad(mtrSociedad);
            }

            if  (StringUtils.isNotBlank(fechaFacturaIni)) {
                Date fecha = DateUtils.convertStringToDate("yyyyMMdd", fechaFacturaIni);
                String sFecha = DateUtils.convertDateToString("dd/MM/yyyy", fecha);
                facFactura.setFechaFacturaIni(sFecha);
            }
            if  (StringUtils.isNotBlank(fechaFacturaFin)) {
                Date fecha = DateUtils.convertStringToDate("yyyyMMdd", fechaFacturaFin);
                String sFecha = DateUtils.convertDateToString("dd/MM/yyyy", fecha);
                facFactura.setFechaFacturaFin(sFecha);
            }
            if  (StringUtils.isNotBlank(fechaEmisionIni)) {
                Date fecha = DateUtils.convertStringToDate("yyyyMMdd", fechaEmisionIni);
                String sFecha = DateUtils.convertDateToString("dd/MM/yyyy", fecha);
                facFactura.setFechaEmisionIni(sFecha);
            }
            if  (StringUtils.isNotBlank(fechaEmisionFin)) {
                Date fecha = DateUtils.convertStringToDate("yyyyMMdd", fechaEmisionFin);
                String sFecha = DateUtils.convertDateToString("dd/MM/yyyy", fecha);
                facFactura.setFechaEmisionFin(sFecha);
            }
            if  (StringUtils.isNotBlank(fechaCreacionIni)) {
                Date fecha = DateUtils.convertStringToDate("yyyyMMdd", fechaCreacionIni);
                String sFecha = DateUtils.convertDateToString("dd/MM/yyyy", fecha);
                facFactura.setFechaCreacionIni(sFecha);
            }
            if  (StringUtils.isNotBlank(fechaCreacionFin)) {
                Date fecha = DateUtils.convertStringToDate("yyyyMMdd", fechaCreacionFin);
                String sFecha = DateUtils.convertDateToString("dd/MM/yyyy", fecha);
                facFactura.setFechaCreacionFin(sFecha);
            }
            if  (mtrEstadoId != 0) {
                MtrEstado mtrEstado = new MtrEstado();
                mtrEstado.setId(mtrEstadoId);
                facFactura.setMtrEstado(mtrEstado);
            }


            SXSSFWorkbook book = this.facFacturaDeltaService.downloadExcelporFiltro(facFactura);
            ByteArrayOutputStream outByteStream;
            byte[] outArray;
            outByteStream = new ByteArrayOutputStream();
            book.write(outByteStream);
            outArray = outByteStream.toByteArray();
            response.setContentLength(outArray.length);
            response.setHeader("Expires:", "0"); // eliminates browser caching
            response.setHeader("Content-Disposition", "attachment; filename=" + excelFileName);
            OutputStream outStream = response.getOutputStream();
            outStream.write(outArray);

            book.dispose();
            book.close();

            outStream.flush();

        } catch (Exception e) {
            String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
            e.printStackTrace();
            throw new RuntimeException(error);
        }

        return new ResponseEntity<>(HttpStatus.OK);
    }


    @ApiOperation(value = "Genera Excel XLSX de registros por Factura", produces = "application/vnd.ms-excel")
    @PostMapping(value = "/_downloadExcelporFiltroPost", produces = { MediaType.APPLICATION_OCTET_STREAM_VALUE })
    public ResponseEntity<?> _downloadExcelporFiltroPost(@RequestBody FiltroReporteFacturaCustom filtro,

            HttpServletResponse response) {
         String tipoFactura = filtro.getTipoFactura();
         String serieFactura = filtro.getSerieFactura();
         String numeroFactura = filtro.getNumeroFactura();
         String numeroFacturaSap = filtro.getNumeroFacturaSap();
         String ruc = filtro.getRuc();
         String razonSocial = filtro.getRazonSocial();
         Integer mtrSociedadId = filtro.getMtrSociedadId();
         String fechaFacturaIni = filtro.getFechaFacturaIni();
         String fechaFacturaFin = filtro.getFechaFacturaFin();
         String fechaEmisionIni = filtro.getFechaEmisionIni();
         String fechaEmisionFin = filtro.getFechaEmisionFin();
         String fechaCreacionIni = filtro.getFechaCreacionIni();
         String fechaCreacionFin = filtro.getFechaCreacionFin();
         Integer mtrEstadoId = filtro.getMtrEstadoId();
         String indicadorConCertificado = filtro.getIndicadorConCertificado();
         String esProveedorExtranjero = filtro.getEsProveedorExtranjero();
         String listaCodigoAcreedor = filtro.getListaCodigoAcreedor();
         String listaMtrEstadoId = filtro.getListaMtrEstadoId();

        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd_hh_mm_ss");
        String nombreArchivo = this.setObtenerNombreArchivoExcel();
        String excelFileName = nombreArchivo + "_" + formatter.format(LocalDateTime.now()) + ".xlsx";

        try {
            FacFactura facFactura = new FacFactura();
            if  (StringUtils.isNotBlank(indicadorConCertificado)) {
                facFactura.setIndicadorConCertificado(indicadorConCertificado);
            }
            if  (StringUtils.isNotBlank(esProveedorExtranjero)) {
                facFactura.setEsProveedorExtranjero(esProveedorExtranjero);
            }
            if  (StringUtils.isNotBlank(listaCodigoAcreedor)) {
                String[] lista = StringUtils.split(listaCodigoAcreedor,'-');
                if (lista != null && lista.length > 0) {
                    List<String> listaFinal = new ArrayList<>();
                    for (String codigo : lista) {
                        listaFinal.add(codigo);
                    }
                    facFactura.setListaCodigoAcreedor(listaFinal);
                }
            }
            if  (StringUtils.isNotBlank(listaMtrEstadoId)) {
                String[] lista = StringUtils.split(listaMtrEstadoId,'-');
                if (lista != null && lista.length > 0) {
                    List<Integer> listaFinal = new ArrayList<>();
                    for (String codigo : lista) {
                        listaFinal.add(new Integer(codigo));
                    }
                    facFactura.setMtrEstadoLista(listaFinal);
                }
            }

            if  (StringUtils.isNotBlank(tipoFactura)) {
                facFactura.setTipoFactura(tipoFactura);
            }
            if  (StringUtils.isNotBlank(tipoFactura)) {
                facFactura.setSerieFactura(serieFactura);
            }
            if  (StringUtils.isNotBlank(numeroFactura)) {
                facFactura.setNumeroFactura(numeroFactura);
            }
            if  (StringUtils.isNotBlank(numeroFacturaSap)) {
                facFactura.setNumeroFacturaSap(numeroFacturaSap);
            }
            if  (StringUtils.isNotBlank(ruc) || StringUtils.isNotBlank(razonSocial)) {
                MtrProveedor mtrProveedor = new MtrProveedor();
                if  (StringUtils.isNotBlank(ruc)) {
                    mtrProveedor.setRuc(ruc);
                }
                if  (StringUtils.isNotBlank(razonSocial)) {
                    mtrProveedor.setRazonSocial(razonSocial);
                }
                facFactura.setMtrProveedor(mtrProveedor);
            }

            if  (mtrSociedadId != 0) {
                MtrSociedad mtrSociedad = new MtrSociedad();
                mtrSociedad.setId(mtrSociedadId);
                facFactura.setMtrSociedad(mtrSociedad);
            }

            if  (StringUtils.isNotBlank(fechaFacturaIni)) {
                Date fecha = DateUtils.convertStringToDate("yyyyMMdd", fechaFacturaIni);
                String sFecha = DateUtils.convertDateToString("dd/MM/yyyy", fecha);
                facFactura.setFechaFacturaIni(sFecha);
            }
            if  (StringUtils.isNotBlank(fechaFacturaFin)) {
                Date fecha = DateUtils.convertStringToDate("yyyyMMdd", fechaFacturaFin);
                String sFecha = DateUtils.convertDateToString("dd/MM/yyyy", fecha);
                facFactura.setFechaFacturaFin(sFecha);
            }
            if  (StringUtils.isNotBlank(fechaEmisionIni)) {
                Date fecha = DateUtils.convertStringToDate("yyyyMMdd", fechaEmisionIni);
                String sFecha = DateUtils.convertDateToString("dd/MM/yyyy", fecha);
                facFactura.setFechaEmisionIni(sFecha);
            }
            if  (StringUtils.isNotBlank(fechaEmisionFin)) {
                Date fecha = DateUtils.convertStringToDate("yyyyMMdd", fechaEmisionFin);
                String sFecha = DateUtils.convertDateToString("dd/MM/yyyy", fecha);
                facFactura.setFechaEmisionFin(sFecha);
            }
            if  (StringUtils.isNotBlank(fechaCreacionIni)) {
                Date fecha = DateUtils.convertStringToDate("yyyyMMdd", fechaCreacionIni);
                String sFecha = DateUtils.convertDateToString("dd/MM/yyyy", fecha);
                facFactura.setFechaCreacionIni(sFecha);
            }
            if  (StringUtils.isNotBlank(fechaCreacionFin)) {
                Date fecha = DateUtils.convertStringToDate("yyyyMMdd", fechaCreacionFin);
                String sFecha = DateUtils.convertDateToString("dd/MM/yyyy", fecha);
                facFactura.setFechaCreacionFin(sFecha);
            }
            if  (mtrEstadoId != 0) {
                MtrEstado mtrEstado = new MtrEstado();
                mtrEstado.setId(mtrEstadoId);
                facFactura.setMtrEstado(mtrEstado);
            }


            SXSSFWorkbook book = this.facFacturaDeltaService.downloadExcelporFiltro(facFactura);
            ByteArrayOutputStream outByteStream;
            byte[] outArray;
            outByteStream = new ByteArrayOutputStream();
            book.write(outByteStream);
            outArray = outByteStream.toByteArray();
            response.setContentLength(outArray.length);
            response.setHeader("Expires:", "0"); // eliminates browser caching
            response.setHeader("Content-Disposition", "attachment; filename=" + excelFileName);
            OutputStream outStream = response.getOutputStream();
            outStream.write(outArray);

            book.dispose();
            book.close();

            outStream.flush();

        } catch (Exception e) {
            String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
            e.printStackTrace();
            throw new RuntimeException(error);
        }

        return new ResponseEntity<>(HttpStatus.OK);
    }

    @RequestMapping(value = "/numPendienteConCertificado",
            method = RequestMethod.GET, produces = {
            MediaType.APPLICATION_JSON_VALUE})
    public ResponseEntity<?> numPendienteConCertificado(HttpServletRequest request) {

        UserSession userSession = this.systemLoggedUser.getUserSession();
        log.error("numFirmaA  userSession " + userSession);
        MtrEstado estado = this.mtrEstadoDeltaRepository.getByCodigoAgrupadoAndCodigoEstado("FA", "FAPF");
        Integer numReg = 0;
        List<FacFacturaCertificado> listax = this.facFacturaCertificadoDeltaRepository.findByEstadoFactura(estado.getId());

        numReg = listax.size();
        //=============================================
        Map<String, TileDynamic> map = new HashMap<>();

        //Inicio
        TileDynamic tile = new TileDynamic();
        Integer contador = numReg;

        tile.setIcon("sap-icon://activities");
        if (contador.intValue() <= 0) {
            tile.setInfo("Num. Pendiente");
        }
        else {
            if (contador.intValue() == 1) {
                tile.setInfo("Num. Pendiente");
            }
            else {
                tile.setInfo("Num. Pendiente");
            }
        }
        tile.setInfoState("Neutral");
        tile.setNumber(new BigDecimal(contador));
        tile.setNumberDigits(1);
        tile.setNumberFactor("");
        tile.setNumberState("Neutral");
        tile.setNumberUnit("");
        //tile.setStateArrow("UP");
        tile.setSubtitle("");
        tile.setTitle("Pendientes de AprobaciÃ³n");

        // return tile;
        //Fin


        map.put("d", tile);
        return new ResponseEntity<>(map, HttpStatus.OK);
    }

    @RequestMapping(value = "/numPendienteSinCertificado",
            method = RequestMethod.GET, produces = {
            MediaType.APPLICATION_JSON_VALUE})
    public ResponseEntity<?> numPendienteSinCertificado(HttpServletRequest request) {

        UserSession userSession = this.systemLoggedUser.getUserSession();
        log.error("numFirmaA  userSession " + userSession);
        MtrEstado estado = this.mtrEstadoDeltaRepository.getByCodigoAgrupadoAndCodigoEstado("FA", "FAPF");
        Integer numReg = 0;
        List<FacFacturaCertificado> listax = this.facFacturaCertificadoDeltaRepository.findByEstadoFactura(estado.getId());
        List<FacFactura> listay = this.facFacturaDeltaRepository.devuelveFacturaPorEstadoId(estado.getId());
        if(listay.size() > listax.size()) {
            numReg = listay.size() - listax.size();
        }
        //=============================================
        Map<String, TileDynamic> map = new HashMap<>();

        //Inicio
        TileDynamic tile = new TileDynamic();
        Integer contador = numReg;

        tile.setIcon("sap-icon://activities");
        if (contador.intValue() <= 0) {
            tile.setInfo("Num. Pendiente");
        }
        else {
            if (contador.intValue() == 1) {
                tile.setInfo("Num. Pendiente");
            }
            else {
                tile.setInfo("Num. Pendiente");
            }
        }
        tile.setInfoState("Neutral");
        tile.setNumber(new BigDecimal(contador));
        tile.setNumberDigits(1);
        tile.setNumberFactor("");
        tile.setNumberState("Neutral");
        tile.setNumberUnit("");
        //tile.setStateArrow("UP");
        tile.setSubtitle("");
        tile.setTitle("Pendientes de AprobaciÃ³n");

        // return tile;
        //Fin


        map.put("d", tile);
        return new ResponseEntity<>(map, HttpStatus.OK);
    }



}
